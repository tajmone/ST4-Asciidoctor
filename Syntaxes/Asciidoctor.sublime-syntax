%YAML 1.2
---
# "Asciidoctor.sublime-syntax"
# ==============================================================================
#                        AsciiDoc Syntax for Asciidoctor
# ==============================================================================
# Syntax definition for Asciidoctor:
# -- https://asciidoctor.org/
# ------------------------------------------------------------------------------
# Copyright (c) Tristano Ajmone, 2019-2024. MIT License.
# Derived from the work by Matt Neuburg and Jakub Jirutka:
#   Copyright 2014 Matt Neuburg <http://www.apeth.net/matt/default.html>
#   Copyright 2015 Jakub Jirutka <jakub@jirutka.cz> and the Asciidoctor Project.
# ------------------------------------------------------------------------------

# For the guidelines on what to scope names to use for what elements,
# see: https://www.sublimetext.com/docs/scope_naming.html

name:    AsciiDoc (Asciidoctor)
version: 2
scope: text.asciidoc
file_extensions:
  - adoc
  - asc
  - asciidoc

variables:
  block_delimiters: '^[_=\.\-]{4,}$'
  attribute_name: '[A-Za-z0-9_][A-Za-z0-9-]*'

contexts:
  prototype:
  - include: escapes
  - include: xml_entities
  - include: preprocessor
  main:
  - include: lists
  - include: blocks
  - include: section_titles
  - include: one_liners
  - include: inline
  - include: characters

#*******************************************************************************
#                                                                              *
#                                H E L P E R S                                 *
#                                                                              *
#*******************************************************************************

# Currently used in this syntax, but useful to have around in order to improve
# source readability.

  force-pop:
    - match: '(?=\S)'
      pop: true

  pop-at-EOL:
    - match: '(?=[\n$])'
      pop: true

  pop2-at-EOL:
    - match: '(?=[\n$])'
      pop: 2

  consume-whitespace:
    - match: '[ \t]+'

  consume-EOL:
    - match: '[\n$]'

#*******************************************************************************
#                                                                              *
#                         B L O C K    E L E M E N T S                         *
#                                                                              *
#*******************************************************************************

  blocks:
    - include: block_literal
    - include: block_comment
    - include: block_listing
    - include: block_source_fenced
    - include: block_sidebar
    - include: block_pass
    - include: block_quote
    - include: block_example
    - include: block_open
    - include: block_table
      # #- include: '#block_paragraph'           # <- COMMENTED OUT IN ORIGINAL! REMOVED by @bsmith-n4

  ################
  # BLOCK COMMENTS
  ################

  # Examples:
  #   ////
  #   A multi-line comment.
  #   Notice it's a delimited block.
  #   ////

  block_comment:
    - match: ^(/{4,})\s*$\n?
      scope: punctuation.definition.comment.begin.asciidoc
      push:
        - meta_include_prototype: false
        - meta_scope: meta.block.comment.content.asciidoc
        - meta_content_scope: comment.block.asciidoc
        - match: ^\1\s*$\n?
          scope: punctuation.definition.comment.end.asciidoc
          pop: true
        # - include: macro



  #################
  # EXAMPLE BLOCKS
  #################
  # Examples:
  #   ====
  #   Lorem ipsum.
  #   ====

  block_example:
    - match: ^(={4,})\s*$\n?
      scope: constant.delimiter.example.begin.asciidoc
      push:
        - meta_scope: meta.block.example.content.asciidoc
        - meta_content_scope: string.unquoted.block.example.asciidoc
        - match: ^\1\s*$\n?
          scope: constant.delimiter.example.end.asciidoc
          pop: true
        - include: lists
        # - include: block_listing
        - include: blocks   # FIXME Is this supposed to be here? It's not in the original, and it looks like a circular reference.
        - include: one_liners
        - include: inline
        - include: characters

  #     Note: Might need to add more includes.
  #

  ################
  # LISTING BLOCKS
  ################
  # Examples:
  #   [source,python]
  #   ----
  #   print "Lorem ipsum."
  #   ----

  block_listing:
    - match: ^(\-{4,})\s*$\n?
      scope: constant.delimiter.listing.begin.asciidoc
      push:
        - meta_scope: meta.embedded.block.listing.asciidoc
        - meta_content_scope: source.block.listing.content.asciidoc
        - match: ^\1\s*$\n?
          scope: constant.delimiter.listing.end.asciidoc
          pop: true
  #   - include: inline_callout



  ######################
  # FENCED SOURCE BLOCKS
  ######################
  # Fenced code block (ala Markdown)
  #
  # Examples:
  #   ```rb
  #   puts 'Hello world!'
  #   ```

  # TODO: Check if fence delimiter can be more than three backticks.
  # TODO: Add lang name from match RegEx group.

  block_source_fenced:
    - match: ^(```)(\w+)?\s*$\n?
      scope: constant.delimiter.listing.begin.asciidoc
      push:
        - meta_scope: meta.embedded.block.listing.asciidoc
        - meta_content_scope: source.block.listing.content.asciidoc
        # - match: ^\1\s*($|\n)
        - match: '^\1\s*$\n?'
          scope: constant.delimiter.listing.end.asciidoc
          pop: true
        # - include: inline_callout


  ################
  # LITERAL BLOCKS
  ################
  # Examples: (must be four or more dots, since three dots is an ellipses)
  #   ....
  #   Lorem ipsum.
  #   ....
  block_literal:
    - match: ^(\.{4,})\s*$\n?
      scope: constant.delimiter.block.literal.begin.asciidoc
      push:
        - meta_scope: meta.block.literal.content.asciidoc
        - meta_content_scope: string.literal.block.delimited.asciidoc
        - match: ^\1\s*$\n?
          scope: constant.delimiter.block.literal.end.asciidoc
          pop: true
        # - match: ^.*$\n?
        #   scope: meta.block.literal.content.asciidoc
        # - include: inline_callout

  #############
  # OPEN BLOCKS
  #############
  # Examples:
  #   --
  #   Lorem ipsum
  #   --

  block_open:
    - match: ^\-\-\s*$\n?
      scope: constant.delimiter.block.open.begin.asciidoc
      push:
        - meta_scope: meta.block.open.asciidoc
        - meta_content_scope: meta.block.open.content.asciidoc
        - match: ^\-\-\s*$\n?
          scope: constant.delimiter.block.open.end.asciidoc
          pop: true
        # @NOTE ORIGIN: Might need to check on these includes:
        - include: lists
        - include: block_comment
        # - include: block_listing
        - include: block_pass
        - include: one_liners
        - include: inline
        - include: characters



  #############
  # PASS BLOCKS
  #############
  # Examples:
  #   ++++
  #   Lorem ipsum
  #   ++++

  block_pass:
    - match: ^(\+{4,})\s*$\n?
      scope: constant.delimiter.block.passthrough.begin.asciidoc
      push:
        - meta_scope: meta.embedded.block.passthrough.asciidoc
        - meta_content_scope: text.xml.block.passthrough.content.asciidoc
        - match: ^\1\s*$\n?
          scope: constant.delimiter.block.passthrough.end.asciidoc
          pop: true
      # - include: text.xml


  ##############
  # QUOTE BLOCKS
  ##############
  # Examples:
  #   ____
  #   Lorem ipsum
  #   ____

  block_quote:
    - match: ^(_{4,})\s*$\n?
      scope: constant.delimiter.block.quote.begin.asciidoc
      push:
        - meta_scope: meta.block.quote.content.asciidoc
        - meta_content_scope: markup.quote.block.asciidoc
        - match: ^\1\s*$\n?
          scope: constant.delimiter.block.quote.end.asciidoc
          pop: true
        - include: one_liners
        - include: inline
        - include: characters
        #  Note: Might need to add more includes.


  #################
  # SIDEBAR BLOCKS
  #################
  # Examples:
  #   ****
  #   Lorem ipsum
  #   ****

  block_sidebar:
    - match: ^(\*{4,})\s*$\n?
      scope: constant.delimiter.block.sidebar.begin.asciidoc
      push:
        - meta_scope: meta.block.sidebar.content.asciidoc
        - meta_content_scope: string.quoted.block.sidebar.asciidoc
        - match: ^\1\s*$\n?
          scope: constant.delimiter.block.sidebar.end.asciidoc
          pop: true
        - include: lists
        - include: block_comment
        - include: block_listing
        - include: one_liners
        - include: inline
        - include: characters
        #  Note: Might need to add more includes.


# -------------------------------------
# @NOTE: Was commented out in original!
# -------------------------------------
#  #block_paragraph:
#  #  comment: |
#  #    TODO
#  #  name: meta.paragraph.asciidoc
#  #  contentName: constant.character
#  #  begin: ^(?=\S)(?![\/|=\-_\.*`]{2,}(?=\s*$))(?!\.\S+)
#  #  end: ^(?:\s*$|(?=[ ]{,3}>.))|(?=[ \t]*\n)(?<=^===|^====|=====|^---|^----|-----)[\t]*\n

  #################
  # INLINE CALLOUTS [TBD!] -- isn't this already implemented elsewhere?
  #################
  # Callout label
  #
  # Examples:
  #   <1>
  #   <42>

  # >>>>>>>>>>>>>>>>>>>>>>>>>>>
  # inline_callout:
  #   comment: |
  #     Callout label
  #
  #     Examples:
  #       <1>
  #       <42>
  #   name: constant.other.callout.asciidoc
  #   match: (?<!\\)(<)\d+(>)
  #   captures:
  #     '1': {name: punctuation.definition.callout.begin.asciidoc}
  #     '2': {name: punctuation.definition.callout.end.asciidoc}
  # <<<<<<<<<<<<<<<<<<<<<<<<<<<



  ###############
  # TABLES BLOCKS
  ###############

  block_table:
    - match: (^\|={3,}\n)
      scope: constant.delimiter.block.table.begin.asciidoc
      set: block_table_inside

  block_table_inside:
    - meta_scope: meta.table.asciidoc
    - match: '\1'
      scope: constant.delimiter.block.table.end.asciidoc
      pop: true
    - match: (^\|={3,}$) # Unbalanced delimiter (ignore it)
    - include: any_comments
    - include: cell_separator

# <span factor><span op><h-align op><v-align op><style op>|
# <duplication factor><duplication op><h-align op><v-align op><style op>|
# <factor><span or duplication op><h-align op><v-align op><style op>|
# <factor><span or duplication op><h-align op><v-align op><style op>|
  cell_separator:
    - match: '(?x)(
        ((?:\.\d+|\d+\.\d+|\d+)\+)?
        (\d+\*)?
        (\.[<>^]|[<>^]\.[<>^]|[<>^])?
        ([adehlms])?
        \|
      )'
      scope: constant.delimiter.cell-separator.asciidoc

#-----------------------------------------------------------------------------#
#                             C H A R A C T E R S                             #
#-----------------------------------------------------------------------------#

  characters:
    - include: attribute_reference
    - include: entity_number
    - include: entity_name
  #   - include: replacement
  #   - include: macro_pass
    - include: macro
    - include: xref
    - include: biblio_anchor
    - include: indexterm_triple
    - include: indexterm_double

  #####################
  # ATTRIBUTE REFERENCE
  #####################
  # Examples:
  #   {my-attribute}

  attribute_reference:
    - match: ({)([A-Za-z0-9_][A-Za-z0-9_-]*)(})
      captures:
        1: constant.character.attributes.reference.begin.asciidoc
        2: support.variable.attribute.asciidoc
        3: constant.character.attributes.reference.end.asciidoc

  ################
  # BIBLIO ANCHORS
  ################
  # Bibliography anchor
  # Examples:
  #   [[[Lorem ipsum]]]

  biblio_anchor:
    # Bad RegEx: Look behind! (forces old RE engine)
    - match: (?<!\[)(\[\[\[)(.*?)(\]\]\])(?!\])
      captures:
        1: punctuation.definition.biblioanchor.begin.asciidoc
        2: storage.type.reference.biblioanchor.asciidoc
        3: punctuation.definition.biblioanchor.end.asciidoc

  #################
  # NUMBER ENTITIES
  #################
  # Numeric character reference
  # Examples:
  #   &#x278a;
  #   &#182;

  entity_number:
    # Bad RegEx: Look behind! (forces old RE engine)
    - match: (?<!\\)&#(x?[0-9a-fA-f]{2,4});
      scope: constant.character.entity.asciidoc

  ################
  # NAMED ENTITIES
  ################
  # Character entity reference
  #     Examples:
  #   &nbsp;
  #   &sup2;

  entity_name:
    # Bad RegEx: Look behind! (forces old RE engine)
    - match: (?<!\\)&([a-zA-Z][a-zA-Z0-9]*);
      scope: constant.character.entity.xml.asciidoc

  ###################
  # FLOW INDEXTERMS
  ###################
  # Double parenthesis indexterm that appears in the text as well as in the index.
  # Examples:
  #   ((Arthur))
  #   (("Doyle, Arthur Conan"))

  indexterm_double:
    # Bad RegEx: Look behind! (forces old RE engine)
    - match: (?<!\()(\({2})([^\(\s].*?)(\){2})(?!\))
      captures:
        1: constant.character.indexterm.double.begin.asciidoc
        3: constant.character.indexterm.double.end.asciidoc
      scope: variable.other.indexterm.double.asciidoc

  ###################
  # CONCEALED INDEXTERMS
  ###################
  # Triple parenthesis indexterm that appears only in the index.
  # Examples:
  #   (((Excalibur)))
  #   (((Sword, Broadsword, Excalibur)))

  indexterm_triple:
    # Bad RegEx: Look behind! (forces old RE engine)
    - match: (?<!\()(\({3})([^\(\s].*?)(\){3})(?!\))
      captures:
        1: constant.character.indexterm.triple.begin.asciidoc
        3: constant.character.indexterm.triple.end.asciidoc
      scope: variable.other.indexterm.triple.asciidoc

  ########
  # MACROS
  ########

  # @NOTE (ORIGINAL): There are other macro notations, but I match only those
  #                   that end in square brackets.

  # @NOTE: We should really have a separate definition for links, which allows
  #        attributes and provides link-specific semantics for `title=""` and
  #        the `^` for `target_blank`, etc.

  macro:
    - match: |
        (?x)
        (?:
          ((?:https?|mailto|ftp|file)  # specify separately so we can mark them as links that TextMate opens
          ?:{1}  # inline only
          \S*)   # (others such as image are partial URLs and/or TextMate cannot handle them)
        |
          (([a-zA-Z0-9][a-zA-Z0-9_]*)
          (:{1,2})
          (\S*))
        )
        (?:(\[)([^\]]*)(\]))
      captures:
        1: markup.underline.link.macro.asciidoc
        3: keyword.control.name.macro.asciidoc
        4: constant.character.separator.macro.asciidoc
        5: markup.underline.target.macro.asciidoc
        6: constant.character.attributes.macro.begin.asciidoc
        7: variable.parameter.attributes.macro.asciidoc
        8: constant.character.attributes.macro.end.asciidoc


  ############
  # PASS MACRO [TBD!]
  ############
  # Passthrough macro
  # Examples:
  #   pass:[Lorem ipsum]
  #   pass::[Lorem ipsum]

  # >>>>>>>>>>>>>>>>>>>>>>>>>>>
  # macro_pass:
  #   comment: |
  #     Passthrough macro
  #
  #     Examples:
  #       pass:[Lorem ipsum]
  #       pass::[Lorem ipsum]
  #   name: meta.macro.pass.asciidoc
  #   contentName: variable.parameter.attributes.macro.pass.asciidoc
  #   begin: |-
  #     (?x)
  #     (pass)
  #     (:{1,2})
  #     (\S*)
  #     (\[)(?=[^\]]*\])
  #   captures:
  #     '1': {name: keyword.control.name.macro.pass.asciidoc}
  #     '2': {name: constant.character.separator.macro.asciidoc}
  #     '3': {name: markup.underline.target.macro.asciidoc}
  #     '4': {name: constant.character.attributes.macro.begin.asciidoc}
  #   end: '\]'
  #   endCaptures:
  #     '0': {name: constant.character.attributes.macro.end.asciidoc}
  #   - include: text.xml
  # <<<<<<<<<<<<<<<<<<<<<<<<<<<

  ##############
  # REPLACEMENTS [TBD!]
  ##############
  # >>>>>>>>>>>>>>>>>>>>>>>>>>>
  #  replacement:
  #    name: constant.character.replacement.asciidoc
  #    match: |-
  #      (?x)
  #      (?<!\\)  # must not be escaped
  #      (
  #        \(C\)
  #        | \(TM\)
  #        | \(R\)
  #        | ((?<!\-)\-\-(?!\-))    # exactly two, and even this may not rule out all that I want to
  #        | ((?<!\.)\.\.\.(?!\.))  # exactly three
  #        | \->
  #        | <\-
  #        | =>
  #        | <=
  #      )
  # <<<<<<<<<<<<<<<<<<<<<<<<<<<


  #######
  # XREFS
  #######
  # Internal cross-reference
  # Examples:
  #   <<lorem>>
  #   <<lorem, see here>>

  xref:
    # Bad RegEx: Look behind! (forces old RE engine)
    - match: (?<!<)(<<)([^,>]*)\s*,?\s*([^>]*)(>>)(?!<)
      captures:
        1: constant.character.xref.begin.asciidoc
        2: variable.parameter.xref.link.asciidoc
        3: variable.parameter.xref.display.asciidoc
        4: constant.character.xref.end.asciidoc
      scope: meta.xref.asciidoc


#*******************************************************************************
#                                                                              *
#                        I N L I N E    E L E M E N T S                        *
#                                                                              *
#*******************************************************************************

  inline:
    - include: passthrough
    - include: curly_quote_double
    - include: curly_quote_single
    - include: strong
    - include: emphasis
    - include: monospaced
    - include: mark
    - include: superscript    # problematic!
    - include: subscript
    # - include: attribute_list

  ######################
  # ATTRIBUTE LIST
  ######################
  #
  # Examples:
  #   [Lorem ipsum] dolor
  #   [red] Lorem ipsum dolor

  attribute_list:
    # Bad RegEx: Look behind! (forces old RE engine)
    - match: |
        (?x)
        (\[[^\]]*?\])?      # might be preceded by an attributes list
        (?<=^|\W)(?<!\\|})  # must be preceded by nonword character, and not by escape or } (attribute)
      captures:
        1: support.variable.attributelist.asciidoc


  ############################
  # TYPOGRAPHIC (Curly) QUOTES
  ############################
  # IMPORTANT: This definition appears before the definition for monospaced in
  # an attempt to give curly quotes priority, but that didn't work. The upshot
  # is that we currently purposefully avoid including monospaced within
  # inside_curly_quote_double, because it interferes with parsing the closing
  # quote anyway. The user can have monospaced syntax with typographic quotes,
  # but it just won't be highlighted as such.
  #
  # Examples:
  #   "`And then he said, '`Tally Ho!`', and off he went.`"

  curly_quote_double:
    # Bad RegEx: Look behind! (forces old RE engine)
    - match: |
        (?x)
        (\[[^\]]*?\])?  # might start with an attribute list
        (?<!\\)         # must not be preceded by escape
        ("`)
      captures:
        1: support.variable.attributelist.asciidoc
        2: punctuation.definition.curlyquote.double.begin.asciidoc
      push: inside_curly_quote_double

  inside_curly_quote_double:
    - meta_content_scope: markup.curlyquote.double.asciidoc
    - meta_scope: meta.curlyquoteinner.double.asciidoc
    - include: curly_quote_single
    - include: strong
    - include: emphasis
    - include: mark
    - include: superscript
    - include: subscript
    - include: attribute_list
    # - include: monospaced  -- see IMPORTANT note, above
    - match: (`")
      scope: punctuation.definition.curlyquote.double.end.asciidoc
      pop: true

  curly_quote_single:
    # Bad RegEx: Look behind! (forces old RE engine)
    - match: |
        (?x)
        (\[[^\]]*?\])?  # might start with an attribute list
        (?<!\\)         # must not be preceded by escape
        ('`)
      captures:
        1: support.variable.attributelist.asciidoc
        2: punctuation.definition.curlyquote.single.begin.asciidoc
      push: inside_curly_quote_single

  inside_curly_quote_single:
    - meta_content_scope: markup.curlyquote.single.asciidoc
    - meta_scope: meta.curlyquoteinner.single.asciidoc
    - include: curly_quote_double
    - include: strong
    - include: emphasis
    - include: mark
    - include: superscript
    - include: subscript
    - include: attribute_list
    # - include: monospaced  -- see IMPORTANT note, above
    - match: (`')
      scope: punctuation.definition.curlyquote.single.end.asciidoc
      pop: true



  ########
  # STRONG
  ########

  strong:
    - include: strong_unconstrained
    - include: strong_constrained

  # STRONG UNCONSTRAINED
  # ====================
  # Was: "STRONG DOUBLE"
  # Strong (bold) text (unconstrained variant).
  # Examples:
  #   Lo**re**m **ipsum dolor**.
  #   Lo[red]**re**m

  strong_unconstrained:
    # Bad RegEx: Look behind! (forces old RE engine)
    - match: |
        (?x)
        (\[[^\]]*?\])?  # might start with an attribute list
        (?<!\\)         # must not be preceded by escape
        (\*\*)
      captures:
        1: support.variable.attributelist.asciidoc
        2: punctuation.definition.bold.double.begin.asciidoc
      push: inside_strong_unconstrained

  inside_strong_unconstrained:
    - meta_content_scope: markup.bold.double.asciidoc
    - meta_scope: meta.boldinner.double.asciidoc
    - include: error_on_empty_line
    - include: line_comment
    - include: emphasis
    - include: monospaced
    - match: \*\*
      scope: punctuation.definition.bold.double.end.asciidoc
      pop: true
      #   - include: emphasis_unconstrained
      #   - include: monospaced_unconstrained
      #   - include: mark_unconstrained
      #   - include: emphasis_constrained
      #   - include: monospaced_constrained
      #   - include: mark_constrained
      #   - include: superscript
      #   - include: subscript
      #   - include: characters




  # STRONG CONSTRAINED
  # ====================
  # Was: "STRONG"
  # Strong (bold) text (unconstrained variant).
  # Examples:
  #   *Lorem ipsum* dolor
  #   [red]*Lorem ipsum* dolor


# @NOTE: This was the original RegEx, which forces the old RE engine due to
#        lookbehind assertions:

  # strong_constrained:
  #   - match: |
  #       (?x)
  #       (\[[^\]]*?\])?      # might start with an attributes list
  #       (?<=^|\W)(?<!\\|})  # must be preceded by non-word char, and not by escape or } (attribute)
  #       (\*)(?=\S)          # star delimiter must be followed by a non-space char
  #     captures:
  #       1: support.variable.attributelist.asciidoc
  #       2: punctuation.definition.bold.single.begin.asciidoc
  #     push: inside_strong_constrained
  strong_constrained:
    - match: (?=\[[^\]]*?\]\*|\*)
      branch_point: branch_strong_constrained
      branch:
        - maybe_strong_constrained
        - literal_asterisk
  maybe_strong_constrained:
    # might start with an attribute list (indeed, that is its purpose)
    - match: (\[[^\]]*?\])(\*)|(\*)
      captures:
        1: support.variable.attributelist.asciidoc
        2: punctuation.definition.bold.single.begin.asciidoc
        3: punctuation.definition.bold.single.begin.asciidoc
      push: inside_strong_constrained
  inside_strong_constrained:
    - meta_content_scope: markup.bold.single.asciidoc
    - meta_scope: meta.boldinner.single.asciidoc
    # An empty line or block delimiters trigger branch failure and rewinding:
    - match: '^$|{{block_delimiters}}'
      fail: branch_strong_constrained
    - include: line_comment
    - include: emphasis
    - include: monospaced
    # Bad RegEx: Look behind! (forces old RE engine)
    - match: |
        (?x)
        (?<=\S)(\*)       # star delimiter must be preceded by a non-space char
        (?!\w)            # ... and followed by a non-word char
      scope: punctuation.definition.bold.single.end.asciidoc
      pop: 2

  literal_asterisk:
    # Scoped only for testing purposes. (maybe useful for plug-ins?)
    - match: '\*'
      scope: constant.character.literal.asterisk
      pop: true


  ##########
  # EMPHASIS
  ##########

  emphasis:
    - include: emphasis_unconstrained
    - include: emphasis_constrained

  # EMPHASIS UNCONSTRAINED
  # ======================
  # Was: "EMPHASIS DOUBLE"
  # Emphasized (italic) text (unconstrained variant).
  # Examples:
  #   Lo__re__m __ipsum dolor__.
  #   Lo[red]__re__m

  emphasis_unconstrained:
    # Bad RegEx: Look behind! (forces old RE engine)
    - match: |
        (?x)
        (\[[^\]]*?\])?  # might start with attribute list
        (?<!\\)         # must not be preceded by escape
        (__)
      captures:
        1: support.variable.attributelist.asciidoc
        2: punctuation.definition.italic.double.begin.asciidoc
      push: inside_emphasis_unconstrained

  inside_emphasis_unconstrained:
    - meta_content_scope: markup.italic.double.asciidoc
    - meta_scope: meta.italicinner.double.asciidoc
    - include: error_on_empty_line
    - include: line_comment
    - include: strong
    - include: monospaced
    - match: '__'
      scope: punctuation.definition.italic.double.end.asciidoc
      pop: true
    #   - include: strong_unconstrained
    #   - include: monospaced_unconstrained
    #   - include: mark_unconstrained
    #   - include: strong_constrained
    #   - include: monospaced_constrained
    #   - include: mark_constrained
    #   - include: superscript
    #   - include: subscript
    #   - include: characters


  # EMPHASIS CONSTRAINED
  # ====================
  # Was: "EMPHASIS"
  # Emphasized (italic) text (constrained variant).
  #
  # Examples:
  #   _Lorem ipsum_ dolor
  #   [red]_Lorem ipsum_ dolor

  emphasis_constrained:
    # Bad RegEx: Look behind! (forces old RE engine)
    - match: |
        (?x)
        (\[[^\]]*?\])?      # might be preceded by an attributes list
        (?<=^|\W)(?<!\\|})  # must be preceded by non-word char, and not by escape or } (attribute)
        (_)(?=\S)           # underscore delimiter must be followed by a non-space char
      captures:
        1: support.variable.attributelist.asciidoc
        2: punctuation.definition.italic.single.begin.asciidoc
      push: inside_emphasis_constrained

  inside_emphasis_constrained:
    - meta_content_scope: markup.italic.single.asciidoc
    - meta_scope: meta.italicinner.single.asciidoc
    - include: error_on_empty_line
    - include: line_comment
    - include: strong
    - include: monospaced
    # Bad RegEx: Look behind! (forces old RE engine)
    - match: |
        (?x)
        (?<=\S)(_)        # underscore delimiter must be preceded by a non-space char
        (?!\w)            # ... and followed by a non-word char
      scope: punctuation.definition.italic.single.end.asciidoc
      pop: true
    # - include: strong_unconstrained
    # - include: monospaced_unconstrained
    # - include: mark_unconstrained
    # - include: strong_constrained
    # - include: monospaced_constrained
    # - include: mark_constrained
    # - include: superscript
    # - include: subscript
    # - include: characters

  ############
  # MONOSPACED
  ############

  monospaced:
    - include: monospaced_unconstrained
    - include: monospaced_constrained

  # MONOSPACED UNCONSTRAINED
  # ========================
  # Was: "MONOSPACED DOUBLE"
  # Monospaced text (unconstrained variant).
  #
  # Examples:
  #   Lo``re``m ``ipsum dolor``.
  #   Lo[red]``re``m

  monospaced_unconstrained:
    # Bad RegEx: Look behind! (forces old RE engine)
    - match: |
        (?x)
        (\[[^\]]*?\])?  # might start with attribute list
        (?<!\\)         # must not be preceded by escape
        (``)
        (?!"|')         # Avoid false positive for closing smart typography
      captures:
        1: support.variable.attributelist.asciidoc
        2: punctuation.definition.literal.double.begin.asciidoc
      push: inside_monospaced_unconstrained

  inside_monospaced_unconstrained:
    - meta_include_prototype: false
    - meta_content_scope: string.other.literal.double.asciidoc
    - meta_scope: meta.literalinner.double.asciidoc
    - include: error_on_empty_line
    - include: line_comment
    - match: '``'
      scope: punctuation.definition.literal.double.end.asciidoc
      pop: true
    # - include: strong_unconstrained
    # - include: emphasis_unconstrained
    # - include: mark_unconstrained
    # - include: strong_constrained
    # - include: emphasis_constrained
    # - include: mark_constrained
    # - include: superscript
    # - include: subscript
    # - include: characters


  # MONOSPACED CONSTRAINED
  # ======================
  # Was: "MONOSPACED"
  # Monospaced text (constrained variant).
  #
  # Examples:
  #   `Lorem ipsum` dolor
  #   [red]`Lorem ipsum` dolor

  monospaced_constrained:
    # False positive: typographic quotes followed by single backtick:
    - match: (["']`)(`(?!`))?
      captures:
        1: punctuation.definition.string.begin.asciidoc
    # False positive: closing typographic quotes:
    - match: (`["'])
      captures:
        1: punctuation.definition.string.end.asciidoc
    # Capture real monospaced formatting:
    # Bad RegEx: Look behind! (forces old RE engine)
    - match: |
        (?x)
        (\[[^\]]*?\])?      # might start with attributes list
        (?<=^|\W)(?<!\\|})  # must be preceded by non-word char, and not by escape or } (attribute)
        (`)(?=\S)           # backtick delimiter must be followed by a non-space char
      captures:
        1: support.variable.attributelist.asciidoc
        2: punctuation.definition.literal.single.begin.asciidoc
      push: inside_monospaced_constrained

  inside_monospaced_constrained:
    - meta_include_prototype: false
    - meta_content_scope: string.other.literal.single.asciidoc
    - meta_scope: meta.literalinner.single.asciidoc
    - include: error_on_empty_line
    - include: line_comment
    # Bad RegEx: Look behind! (forces old RE engine)
    - match: |
        (?x)
        (?<=\S)(`)        # backtick delimiter must be preceded by a non-space char
        (?!\w)            # ... and followed by a non-word char
      scope: punctuation.definition.literal.single.end.asciidoc
      pop: true
  #   - include: strong_unconstrained
  #   - include: emphasis_unconstrained
  #   - include: mark_unconstrained
  #   - include: strong_constrained
  #   - include: emphasis_constrained
  #   - include: mark_constrained
  #   - include: superscript
  #   - include: subscript
  #   - include: characters



  #############
  # PASSTHROUGH
  #############
  # Inline triple-plus and double dollar passthrough.
  # Examples:
  #   Lo+++re++++m +++ipsum dolor+++.
  #   Lo$$re$$m $$ipsum dolor$$.

  # @NOTE ORIGINAL: Must be dead-first among the inlines, so as to take priority.

  passthrough:
    - match: (\+\+\+|\$\$)
      scope: constant.character.passthrough.begin.asciidoc
      push:
        - meta_scope: meta.passthrough.inline.asciidoc
        - meta_content_scope: variable.parameter.passthroughinner.asciidoc
        - match: \1
          scope: constant.character.passthrough.end.asciidoc
          pop: true

  ####################
  # MARK UNCONSTRAINED
  ####################

  mark:
    - include: mark_unconstrained
    - include: mark_constrained

  # MARK UNCONSTRAINED
  # ==================
  # Was: "MARK DOUBLE"
  # Marked text (unconstrained variant).
  # Examples:
  #   Lo##re##m ##ipsum dolor##.
  #   Lo[red]##re##m

  mark_unconstrained:
    # Bad RegEx: Look behind! (forces old RE engine)
    - match: |
        (?x)
        (\[[^\]]*?\])?  # might start with an attribute list (indeed, that is its purpose)
        (?<!\\)         # must not be preceded by escape
        (\#\#)
      captures:
        1: support.variable.attributelist.asciidoc
        2: punctuation.definition.string.unquoted.double.begin.asciidoc
      push: mark_unconstrained_inside

  mark_unconstrained_inside:
    - meta_scope: string.other.unquoted.double.asciidoc
    - meta_content_scope: string.unquoted.unquotedinner.double.asciidoc
    - match: \#\#
      scope: punctuation.definition.string.unquoted.double.end.asciidoc
      pop: true
    - include: error_on_empty_line # mitigate literal '#' false positives!
    #   - include: strong_unconstrained
    #   - include: emphasis_unconstrained
    #   - include: monospaced_unconstrained
    #   - include: strong_constrained
    #   - include: emphasis_constrained
    #   - include: monospaced_constrained
    #   - include: superscript
    #   - include: subscript
    #   - include: characters


  # MARK CONSTRAINED
  # ================
  # Was: "MARK"
  # Marked text (constrained variant).
  # Examples:
  #   #Lorem ipsum# dolor
  #   [red]#Lorem ipsum# dolor

    # NOTE: The '&' in `(?<![\\}&])` was added to ensure it's not preceded by
    #       an & to avoid matching HTML entities like '&#182;'. It could be
    #       removed once HTML entities are properly handled by the syntax, but
    #       we'll need to ensure that they always have precedence over this.
  mark_constrained:
    - match: (?=\[[^\]]*?\]\#|\#)
      branch_point: branch_mark_constrained
      branch:
        - maybe_mark_constrained
        - literal_hash

# @NOTE: This was the original RegEx, which forces the old RE engine due to
#        lookbehind assertions:
    # - match: |
    #     (?x)
    #     (\[[^\]]*?\])?       # might start with attribute list (darned well better or why are we here)
    #     (?<=^|\W)(?<![\\}&]) # must be preceded by non-word char, and not by escape or } (attribute)
    #     (\#)(?=\S)           # hash delimiter must be followed by a non-space char
  maybe_mark_constrained:
    # might start with an attribute list (indeed, that is its purpose)
    - match: (\[[^\]]*?\])(\#)|(\#)
      captures:
        1: support.variable.attributelist.asciidoc
        2: punctuation.definition.string.unquoted.single.begin.asciidoc
        3: punctuation.definition.string.unquoted.single.begin.asciidoc
      push: mark_inside
  mark_inside:
    - meta_scope: string.other.unquoted.single.asciidoc
    - meta_content_scope: string.unquoted.unquotedinner.single.asciidoc
    # - match: '\\\#'
    #   scope: constant.character.escape.asciidoc
    #   pop: 2
    - match: '\#'
      scope: punctuation.definition.string.unquoted.single.end.asciidoc
      pop: 2
    # An empty line or block delimiters trigger branch failure and rewinding:
    - match: '^$|{{block_delimiters}}'
      fail: branch_mark_constrained
  # - include: error_on_empty_line # <- old workaround, replaced by branching.
# @TODO: Add 'include's for possible inline formatting:
    # - include: strong_unconstrained
    # - include: emphasis_unconstrained
    # - include: monospaced_unconstrained
    # - include: strong_constrained
    # - include: emphasis_constrained
    # - include: monospaced_constrained
    # - include: superscript
    # - include: subscript
    # - include: characters

  literal_hash:
    # Scoped only for testing purposes. (maybe useful for plug-ins?)
    - match: '\#'
      scope: constant.character.literal.hash.asciidoc
      # scope: punctuation.definition.hash
      pop: true

  ###########
  # SUBSCRIPT
  ###########
  # Subscript text.
  # Examples:
  #   H~2~O
  #   H[red]~2~O

  subscript:
    # Bad RegEx: Look behind! (forces old RE engine)
    - match: |
        (?x)
        (\[[^\]]*?\])?  # might start with attribute list
        (?<!\\)         # must not be preceded by escape
        (~)
      captures:
        1: support.variable.attributelist.asciidoc
        2: punctuation.definition.string.subscript.begin.asciidoc
      push:
        - meta_scope: meta.subscriptinner.asciidoc
        - meta_content_scope: string.other.subscript.asciidoc
        - match: \~
          scope: punctuation.definition.string.subscript.end.asciidoc
          pop: true
      #   - include: strong_unconstrained
      #   - include: emphasis_unconstrained
      #   - include: monospaced_unconstrained
      #   - include: mark_unconstrained
      #   - include: strong_constrained
      #   - include: emphasis_constrained
      #   - include: monospaced_constrained
      #   - include: mark_constrained
      #   - include: superscript
      #   - include: characters



  #############
  # SUPERSCRIPT
  #############
  # Superscript text.
  # Examples:
  #   E=mc^2^
  #   E=mc[red]^2^

  superscript:
    # Bad RegEx: Look behind! (forces old RE engine)
    - match: |
        (?x)
        (\[[^\]]*?\])?  # might start with attribute list
        (?<!\\)         # no preceding escape
        (\^)
      captures:
        1: support.variable.attributelist.asciidoc
        2: punctuation.definition.string.superscript.begin.asciidoc
      push:
        - meta_scope: meta.superscriptinner.asciidoc
        - meta_content_scope: string.other.superscript.asciidoc
        - match: \^
          scope: punctuation.definition.string.superscript.end.asciidoc
          pop: true
      #   - include: strong_unconstrained
      #   - include: emphasis_unconstrained
      #   - include: monospaced_unconstrained
      #   - include: mark_unconstrained
      #   - include: strong_constrained
      #   - include: emphasis_constrained
      #   - include: monospaced_constrained
      #   - include: mark_constrained
      #   - include: subscript
      #   - include: characters



#*******************************************************************************
#                                                                              *
#                   S I N G L E - L I N E    E L E M E N T S                   *
#                                                                              *
#*******************************************************************************
# Syntax constructs that appear on a single-line, on their own, including those
# which can span across multiple lines via a line-continuation (' \' or ' + \'):
#
# https://docs.asciidoctor.org/asciidoc/latest/attributes/wrap-values/
# https://docs.asciidoctor.org/asciidoc/latest/attributes/wrap-values/#hard

# Try to keep them in order of importance (most common first):

  one_liners:
    - include: line_comment
    - include: list_continuation
    - include: inline_break # Not a single-liner! Move to reusables!
    - include: block_title
    - include: attribute_entry
    - include: attribute_list_line
    - include: one_liners_sq-bracketed # i.e. all '[...]' elements
    - include: block_page_break
    - include: block_thematic_break

  ######################
  # SINGLE-LINE COMMENTS
  ######################
  # Inline comment. (?)
  # Examples:
  #   // This is just a comment!
  line_comment:
    - match: ^(//)([^/\n].*|)$\n?
      scope: comment.line.double-slash.asciidoc
      captures:
        1: punctuation.definition.comment.line.asciidoc
        2: meta.line.comment.content.asciidoc

  #################
  # ATTRIBUTE ENTRY
  #################
  # An attribute entry.
  # Technically, this is not strictly a single-line construct since it can
  # span multiple lines via a ' \' or ' + \' line-continuation token.
  # Examples:
  #   :my-attribute: value
  #   :sectnums!:
  #   :!sectnums:

  attribute_entry:
    # TODO: Support line continuations via ' \' (soft-wrap) or ' + \' (hard-wrap)
    - match: |
        (?x)
        ^(:)                          # 1: opening delimiter
        (!)?                          # 2: bang symbol (unset attribute)
        ([A-Za-z0-9_][A-Za-z0-9_-]*)  # 3: attribute name
        (!)?                          # 4: bang symbol (unset attribute)
        (:)                           # 5: closing delimiter
        (?:\s+|(?=$))                 # ? consume WS?
      captures:
        1: punctuation.definition.attributeentry.attrname.begin.asciidoc
        2: punctuation.definition.attributeentry.unset.asciidoc
        3: support.variable.attribute.asciidoc
        4: punctuation.definition.attributeentry.unset.asciidoc
        5: punctuation.definition.attributeentry.attrname.end.asciidoc
      push:
        - meta_scope: meta.attributeentry.asciidoc
        - meta_content_scope: meta.attributeentry.value.asciidoc
        - match: $\n?
          pop: true
        #   - include: characters

  #############
  # BLOCK TITLE
  #############
  # Title of a block. Excludes custom block titles for better
  # scoping / preventing overlap.
  # NOTE: Does this construct support line-continuation via ' \'?
  # Examples:
  #   .My title
  #   Lorem ipsum dolor.

  block_title:
    - match: ^(\.)(\w.*)$\n?
      captures:
        1: punctuation.definition.blockheading.asciidoc
        2: markup.heading.block.asciidoc


  ###########
  # BLOCK REQ [TBD!]
  ###########
  # A requirement id (i.e. anchor).
  # Examples:
  #   [req,id=ROPR1234,version=1]
  #   Lorem ipsum dolor.

  # IMPORTANT: This element was ADDED by @bsmith-n4!
  #            Can't find any references to this in the docs.

  # >>>>>>>>>>>>>>>>>>>>>>>>>>>                         # <- ADDED by @bsmith-n4
  # block_req:
  #   comment: |
  #     A requirement id (i.e. anchor).
  #     Examples:
  #       [req,id=ROPR1234,version=1]
  #       Lorem ipsum dolor.
  #   name: meta.tag.blockid.req.asciidoc
  #   match: (\[req,(\s+)?id=)(.+?)(,(\s+)?version=)([0-9])(\])
  #   captures:
  #     '1': {name: markup.underline.block.id.asciidoc}
  #     '3': {name: variable.parameter.reqid.id.asciidoc}
  #     '4': {name: markup.underline.block.version.asciidoc}
  #     '6': {name: variable.parameter.reqversion.id.asciidoc}
  #     '7': {name: markup.underline.block.id.asciidoc}
  # <<<<<<<<<<<<<<<<<<<<<<<<<<<


  ##############
  # INLINE BREAK
  ##############
  # Line hard break with a plus sign (+).
  # Examples:
  #   Rubies are red, +
  #   Topazes are blue.

  inline_break:
    # Bad RegEx: Look behind! (forces old RE engine)
    - match: (?<=\s)\+$\n?
      scope: constant.linebreak.asciidoc



  ###################
  # LIST CONTINUATION
  ###################
  # See: §20.2.1. List continuation
  # https://asciidoctor.org/docs/user-manual/#list-continuation

  # Examples:
  #  * First list element paragraph.
  #  +
  #  Second element paragraph (no bullet).

  list_continuation:
    - match: ^\+\s*$\n?
      scope: constant.listcontinuation.asciidoc


  ##################
  # BLOCK PAGE BREAK
  ##################
  # A page break.
  # Examples:
  #   <<<
  #   <<<<<

  block_page_break:
    - match: ^<{3,}$\n?
      scope: meta.separator.pagebreak.asciidoc


  ######################
  # BLOCK THEMATIC BREAK
  ######################
  # A thematic break (aka. horizontal rule, aka. scene break).
  # Examples:
  #   '''
  #   ''''''

  block_thematic_break:
    - match: ^'{3,}$\n?
      scope: meta.separator.ruler.asciidoc

# ==============================================================================
#                P R E P R O C E S S O R   D I R E C T I V E S
# ==============================================================================
# Although conditional directives might define logical blocks, from a syntax
# standpoint they are just single-line constructs, so they belong here.
# NOTE: 'preprocessor' belongs to the 'prototype' context!

  preprocessor:
    - include: pp_def
    - include: pp_eval
    - include: pp_endif
    - include: pp_include

  pp_endif:
    - match: '^(endif)(\:\:)({{attribute_name}})?((\[)(\]))'
      captures:
        0: meta.preprocessor.conditional.endif.asciidoc
        1: keyword.control.preprocessor.conditional.endif.asciidoc
        2: punctuation.definition.keyword.preprocessor.asciidoc
        3: support.variable.attribute.asciidoc
        4: meta.brackets.asciidoc
        5: punctuation.section.brackets.begin.preprocessor.asciidoc
        6: punctuation.section.brackets.end.preprocessor.asciidoc

  pp_def:
    - match: '^((ifdef)|(ifndef))(\:\:)'
      captures:
        2: keyword.control.preprocessor.conditional.ifdef.asciidoc
        3: keyword.control.preprocessor.conditional.ifndef.asciidoc
        4: punctuation.definition.keyword.preprocessor.asciidoc
      push: pp_def_inside
  pp_def_inside:
    - meta_scope: meta.preprocessor.conditional.asciidoc
    - include: pop-at-EOL # fail-safe: bail out if malformed
    # TBD: Handle malformed attribute names (See #51)
    # TBD: Support multiple attributes via ',' and '+' operators
    - match: '(({{attribute_name}})((,)|(\+))?)?'
      captures:
        2: support.variable.attribute.asciidoc
        4: keyword.operator.logical.or.asciidoc
        5: keyword.operator.logical.and.asciidoc
    - match: '\['
      scope: punctuation.section.brackets.begin.preprocessor.asciidoc
      push: pp_def_inside2
  pp_def_inside2:
    - meta_scope: meta.brackets.asciidoc
    - include: pop2-at-EOL # fail-safe: bail out if malformed
    - match: '\]'
      scope: punctuation.section.brackets.end.preprocessor.asciidoc
      pop: 2

  pp_eval:
    - match: '^(ifeval)(\:\:)(\[)'
      captures:
        1: keyword.control.preprocessor.conditional.ifeval.asciidoc
        2: punctuation.definition.keyword.preprocessor.asciidoc
        3: punctuation.section.brackets.begin.preprocessor.asciidoc
      push: pp_eval_inside
  pp_eval_inside:
    - meta_scope: meta.preprocessor.conditional.asciidoc
                  meta.brackets.asciidoc
    - include: pop-at-EOL # fail-safe: bail out if malformed
    # TBD: capture attributes, operators, false/true, values, etc.
    - match: '\]'
      scope: punctuation.section.brackets.end.preprocessor.asciidoc
      pop: true

  pp_include:
    # TBD: Distinguish between include by file and URI.
    - match: '^(include)(\:\:)([^\[]+)(\[)'
      captures:
        1: keyword.control.preprocessor.conditional.include.asciidoc
        2: punctuation.definition.keyword.preprocessor.asciidoc
        3: string.unquoted.preprocessor.asciidoc
        4: punctuation.section.brackets.begin.preprocessor.asciidoc
      push: pp_include_inside
  pp_include_inside:
    - meta_scope: meta.preprocessor.conditional.asciidoc
                  meta.brackets.asciidoc
    - include: pop-at-EOL # fail-safe: bail out if malformed
    # TBD: capture tags, line-ranges, level-offsets, etc.
    - match: '\]'
      scope: punctuation.section.brackets.end.preprocessor.asciidoc
      pop: true

# ==============================================================================
#             S Q U A R E - B R A C K E T E D   O N E - L I N E R S
# ==============================================================================
# All single-line constructs enclosed within square-brackets '[ ... ]' should
# be placed in this group.

# IMPORTANT: These constructs tolerate trailing spaces and tabs, so we must
#            ensure that RegEx pattern consume them without scoping them.

  one_liners_sq-bracketed:
    - include: attribute_list_line
    - include: block_id
  #   - include: block_req                              # <- ADDED by @bsmith-n4
  #   - include: section_template

  #####################
  # ATTRIBUTE LIST LINE
  #####################
  # Attribute list as paragraph: single brackets. No need for special
  # treatment of escape; follows literal block, section template as being a
  # more general regex.

  attribute_list_line:
    - match: ^(\[)[^\[\]]*(\])\s*$\n?
      captures:
        0: support.variable.attributelist.asciidoc
        1: punctuation.definition.attributelistline.begin.asciidoc
        2: punctuation.definition.attributelistline.end.asciidoc


  ##########
  # BLOCK ID
  ##########
  # A block id (i.e. anchor).
  # Examples:
  #   [[myid]]
  #   Lorem ipsum dolor.

  block_id:
    - match: ^(\[\[)([^\[].*)(\]\])\s*$\n?
      captures:
        0: meta.tag.blockid.asciidoc
        1: punctuation.definition.blockid.begin.asciidoc
        2: entity.name.label.asciidoc
        3: punctuation.definition.blockid.end.asciidoc


  ##################
  # SECTION TEMPLATE [TBD!]
  ##################
  # Fixed list of known template names
  # See: §16.9. Section Styles
  # https://asciidoctor.org/docs/user-manual/#section-styles

  # IMPORTANT: This element differs in @bsmith-n4 and original!
  #
  # section_template:
  #   comment: fixed list of known template names
  #   name: variable.parameter.sectiontemplate.asciidoc
  #   match: |-



  # >>>>>>>>>>>>>>>>>>>>>>>>>>>
  # section_template:
  #   comment: fixed list of known template names
  #   name: variable.parameter.sectiontemplate.asciidoc
  #   match: |                       # <- CHANGED by @bsmith-n4 (was: match: |-)
  #     (?x)^
  #     (\[)  # in square brackets
  #     (template\s*=\s*)?(")?  # might start with template-equals and might have template name in quotes
  #     (
  #     sect\d|abstract|preface|colophon|dedication|glossary|bibliography|synopsis|appendix|index # fixed list of known templates
  #     )
  #     (".*(\])|(\]))  # either close the quote (and perhaps go on) and close the bracket, or close the bracket immediately
  #     \s*$\n?
  #   captures:
  #     '1': {name: punctuation.definition.sectiontemplate.begin.asciidoc}
  #     '4': {name: meta.tag.sectiontemplate.asciidoc}
  #     '6': {name: punctuation.definition.sectiontemplate.end.asciidoc}
  #     '7': {name: punctuation.definition.sectiontemplate.end.asciidoc}
  # <<<<<<<<<<<<<<<<<<<<<<<<<<<

#*******************************************************************************
#                                                                              *
#                                  L I S T S                                   *
#                                                                              *
#*******************************************************************************
# NOTE: For lists (and similar), we don't to try to match on the entire
#       paragraph, just the opening syntax.

  lists:
    - include: ulist_item_marker
    - include: block_admonition_label
    - include: olist_item_marker
    - include: dlist_item_label
    - include: colist_item_marker

  ########################
  # ADMONITION BLOCK LABEL
  ########################
  # Label of an admonition block.
  # Examples:
  #   NOTE: This is a admonition block.
  #   WARNING:  Be aware of them!


  block_admonition_label:
    - match: ^(NOTE|TIP|IMPORTANT|WARNING|CAUTION):(?=\s+)
      scope: support.constant.admonitionword.asciidoc


  ###################
  # ULIST ITEM MARKER
  ###################
  # Marker of an unordered (bullet) list item.
  # Examples:
  #   - level 1
  #   * level 1
  #   ** level 2
  #   *** level 3
  #   **** level 4
  #   ***** level 5

  ulist_item_marker:
    - match: ^\s*(\-|\*{1,5})\s+(?=\S)
      captures:
        1: punctuation.definition.list_item.asciidoc

# Markdwon scopes:
#    text.html.markdown.gfm
#    markup.list.unnumbered.markdown
#    punctuation.definition.list_item.markdown

      # scope: markup.list.bulleted.asciidoc


  ####################
  # COLIST ITEM MARKER
  ####################
  # Marker of a callout list item.
  # Examples:
  #   <1> a callout
  #   <42> another callout

  colist_item_marker:
    - match: ^(\s*((<)\d+?(>)))\s+(?=\S)
      captures:
        1: string.unquoted.list.callout.asciidoc
        2: constant.numeric.callout.asciidoc
        3: punctuation.definition.calloutlistnumber.begin.asciidoc
        4: punctuation.definition.calloutlistnumber.end.asciidoc

  ##################
  # DLIST ITEM LABEL
  ##################
  # Label of a definition (labeled) list item.
  # Examples:
  #   Label level 1:: lorem ipsum
  #   Label level 2::: dolor sit amet
  #   Label level 3:::: consectetur
  #   Label level 1::
  #     lorem ipsum
  #   Another label :: lorem ipsum
  #   Last::label:: dolor sit amet

  # @NOTE (ORIGINAL):
  #     This rule is not strictly correct, because Asciidoctor allows
  #     double colon followed by a space inside a label, i.e. it matches the
  #     *last* double colon, not the first. I don't know how to do that
  #     *effectively.

  dlist_item_label:
    - match: ^[^:]*(:{2,4}|;;)(?:\s|$\n?)
      captures:
        1: punctuation.definition.list.labeled.asciidoc

  ###################
  # OLIST ITEM MARKER
  ###################
  # Marker of an ordered (numbered) list item.
  # Examples:
  #   . level 1
  #   .. level 2
  #   ... level 3
  #   .... level 4
  #   ..... level 5

  olist_item_marker:
    - match: ^\s*(\.{1,5})\s+(?=\S)
      captures:
        1: punctuation.definition.list_item.asciidoc


# ==============================================================================
#                          S E C T I O N    T I T L E S
# ==============================================================================

# IMPORTANT: All Titles RegExs were tweaked by @bsmith-n4! Basically, every
#            RegEx was tweaked to allow inline code inside the title:
#
#               match: ^(=) (\w.*)$\n?     <-- original
#               match: ^(=) (`?\w.*)$\n?   <-- @bsmith-n4


#     Examples:
#
#       = Document Title (Level 0)
#
#       == Level 1 Section
#
#       === Level 2 Section
#

  section_titles:
    - include: title_level_5
    - include: title_level_4
    - include: title_level_3
    - include: title_level_2
    - include: title_level_1
    - include: title_level_0

  title_level_0:
    - match: ^(=) (`?\w.*)$\n?
      scope: markup.heading.0.asciidoc
      captures:
        1: punctuation.definition.heading.asciidoc
        2: entity.name.section.asciidoc

  title_level_1:
    - match: ^(==) (`?\w.*)$\n?
      scope: markup.heading.1.asciidoc
      captures:
        1: punctuation.definition.heading.asciidoc
        2: entity.name.section.asciidoc


  title_level_2:
    - match: ^(===) (`?\w.*)$\n?
      scope: markup.heading.2.asciidoc
      captures:
        1: punctuation.definition.heading.asciidoc
        2: entity.name.section.asciidoc


  title_level_3:
    - match: ^(====) (`?\w.*)$\n?
      scope: markup.heading.3.asciidoc
      captures:
        1: punctuation.definition.heading.asciidoc
        2: entity.name.section.asciidoc

  title_level_4:
    - match: ^(=====) (`?\w.*)$\n?
      scope: markup.heading.4.asciidoc
      captures:
        1: punctuation.definition.heading.asciidoc
        2: entity.name.section.asciidoc

  title_level_5:
    - match: ^(======) (`?\w.*)$\n
      scope: markup.heading.5.asciidoc
      captures:
        1: punctuation.definition.heading.asciidoc
        2: entity.name.section.asciidoc


#*******************************************************************************
#                                                                              *
#                              R E U S A B L E S                               *
#                                                                              *
#*******************************************************************************
# Reusable contexts...

# TBD: context for "line continuation" via ' \' (soft-wrap) and ' + \' (hard-wrap)
#      which should be reusable by all contexts that allow it:
#      https://docs.asciidoctor.org/asciidoc/latest/attributes/wrap-values/
#      https://docs.asciidoctor.org/asciidoc/latest/attributes/wrap-values/#hard


  #####################
  # ERROR ON EMPTY LINE
  #####################
  # Some element (e.g. quotes) can span multiple lines as long as no empty line
  # is placed between the opening and closing delimiter...
  error_on_empty_line:
    - match: ^\n$
      scope: invalid.illegal.asciidoc
      pop: true

  ##############
  # ANY COMMENTS
  ##############
  # Include any type of comments.
  any_comments:
    - include: line_comment
    - include: block_comment

#*******************************************************************************
#                                                                              *
#                            M I S C E L A N N E A                             *
#                                                                              *
#*******************************************************************************
# Various definitions added by me, some of which still unused except for tests!

  ####################
  # TYPOGRAPHIC QUOTES
  ####################
  # Added by me to prevent false-positives with monospace...
  # STATUS: UNUSED DRAFT!

  curly_quotes: # NOT USED!
    - match: ("|')(`)
      scope: punctuation.definition.string.begin.asciidoc
    - match: (`)("|')
      scope: punctuation.definition.string.end.asciidoc
      # push:
      #   - match: (`)(\1)
      #     scope: punctuation.definition.string.end.asciidoc
      #     pop: true
      #   - include: monospaced_unconstrained # Single backticks are literals!

#*******************************************************************************
#                                                                              *
#                             P R O T O T Y P E S                              *
#                                                                              *
#*******************************************************************************

  #########
  # ESCAPES
  #########
  # In AsciiDoc, certain characters need to be escaped with a backslash,
  # either a single '/' or double '//' depending on whether the special
  # char occurs once or twice, respectively.
  # @TODO: These might not be complete lists of characters which can be escaped.
  #        Originally:
  #        - match: \\(?=[-`*_#+.!(){}\[\]\\>:])
  # @TODO: The double-escape characters are just guesses, need to check them.

  escapes:
    - include: escapes_double # (1)
    - include: escapes_single # (2)
  escapes_double:
    # chars: # & - ` * _ + . ! ( ) { } [ ] \ > :
    - match: '\\\\[\#&\-`*_+\.!(){}\[\]\\>:]{2}'
      scope: constant.character.escape.double.asciidoc
  escapes_single:
    # chars: # & - ` * _ + . ! ( ) { } [ ] \ > :
    - match: '\\[\#&\-`*_+\.!(){}\[\]\\>:]'
      scope: constant.character.escape.single.asciidoc


  ##############
  # XML ENTITIES
  ##############

  xml_entities:
    - include: xml_entity_decimal
    - include: xml_entity_hexadecimal
    - include: xml_entity_named

  xml_entity_decimal:
    # Examples: &#182;
    - match: '&#([\d]{2,4});'
      scope: constant.character.entity.xml.decimal.asciidoc

  xml_entity_hexadecimal:
    # Examples: &#x278a; &#x278A; &#182;
    - match: '&#(x[0-9a-fA-f]{2,4});'
      scope: constant.character.entity.xml.hexadecimal.asciidoc

  xml_entity_named:
    # Examples: &nbsp; &sup2;
    - match: '&([a-zA-Z][a-zA-Z0-9]*);'
      scope: constant.character.entity.xml.named.asciidoc

# /// EOF ///
