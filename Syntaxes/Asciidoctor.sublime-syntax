%YAML 1.2
---
# "Asciidoctor.sublime-syntax" v0.0.30 | 2020/11/15
# ==============================================================================
#                        AsciiDoc Syntax for Asciidoctor
# ==============================================================================
# Syntax definition for Asciidoctor:
# -- https://asciidoctor.org/
# ------------------------------------------------------------------------------
# ------------------------------------------------------------------------------
# Copyright (c) Tristano Ajmone, 2019. MIT License.
# ------------------------------------------------------------------------------

name:    AsciiDoc (Asciidoctor)
comment: AsciiDoc Syntax
file_extensions:
  - ad
  - adoc
  - asciidoc
scope: text.asciidoc

# variables:

contexts:
  main:
  - include: lists
  - include: blocks
  - include: section_titles
  - include: lines
  - include: inline
  - include: characters

#*******************************************************************************
#                                                                              *
#                        D U M M Y   C O N S U M E R S                         *
#                                                                              *
#*******************************************************************************

# Some definitions whose goal is just capturing some elements to prevent false
# positives that break the document. Some of this will later on be replaced with
# proper capturing elemeents, but for now they are needed to keep the syntax
# from falling apart...

  # We need this to consume table option like `[cols="3*^"]`, otherwise the `^`
  # for columns/cells alignments gets parsed as a Superscript opening delimiter,
  # thus breaking up the whole document...
  dummy_table_opts:
    - match: ^\[cols=".*?\]$

#*******************************************************************************
#                                                                              *
#                         B L O C K    E L E M E N T S                         *
#                                                                              *
#*******************************************************************************

  blocks:
    - include: block_literal
    - include: block_comment
    - include: block_listing
    - include: block_source_fenced
    - include: block_sidebar
    - include: block_pass
    - include: block_quote
    - include: block_example
    - include: block_open
      # #- include: '#block_paragraph'           # <- COMMENTED OUT IN ORIGINAL! REMOVED by @bsmith-n4

  ################
  # BLOCK COMMENTS
  ################

  # Examples:
  #   ////
  #   A multi-line comment.
  #   Notice it's a delimited block.
  #   ////

  block_comment:
    - match: ^(/{4,})\s*$\n?
      scope: punctuation.definition.comment.begin.asciidoc
      push:
        - meta_scope: meta.block.comment.content.asciidoc
        - meta_content_scope: comment.block.asciidoc
        - match: ^\1\s*$\n?
          scope: punctuation.definition.comment.end.asciidoc
          pop: true
        # - include: macro



  #################
  # EXAMPLE BLOCKS
  #################
  # Examples:
  #   ====
  #   Lorem ipsum.
  #   ====

  block_example:
    - match: ^(={4,})\s*$\n?
      scope: constant.delimiter.example.begin.asciidoc
      push:
        - meta_scope: meta.block.example.content.asciidoc
        - meta_content_scope: string.unquoted.block.example.asciidoc
        - match: ^\1\s*$\n?
          scope: constant.delimiter.example.end.asciidoc
          pop: true
        - include: lists
        # - include: block_listing
        - include: blocks
        - include: lines
        - include: inline
        - include: characters

  ################
  # LISTING BLOCKS
  ################
  # Examples:
  #   ----
  #   Lorem ipsum.
  #   ----

  block_listing:
    - match: ^(\-{4,})\s*$\n?
      scope: constant.delimiter.listing.begin.asciidoc
      push:
        - meta_scope: meta.embedded.block.listing.asciidoc
        - meta_content_scope: source.block.listing.content.asciidoc
        - match: ^\1\s*$\n?
          scope: constant.delimiter.listing.end.asciidoc
          pop: true
  #   - include: inline_callout



  ######################
  # FENCED SOURCE BLOCKS
  ######################
  # Fenced code block (ala Markdown)
  #
  # Examples:
  #   ```rb
  #   puts 'Hello world!'
  #   ```

  # TODO: Check if fence delimiter can be more than three backticks.
  # TODO: Add lang name from match regex group.

  block_source_fenced:
    - match: ^(```)(\w+)?\s*$\n?
      scope: constant.delimiter.listing.begin.asciidoc
      push:
        - meta_scope: meta.embedded.block.listing.asciidoc
        - meta_content_scope: source.block.listing.content.asciidoc
        # - match: ^\1\s*($|\n)
        - match: '^\1\s*$\n?'
          scope: constant.delimiter.listing.end.asciidoc
          pop: true
        # - include: inline_callout


  ################
  # LITERAL BLOCKS
  ################
  # Examples:
  #   ....
  #   Lorem ipsum.
  #   ....
  block_literal:
    - match: ^(\.{4,})\s*$\n?
      scope: constant.delimiter.block.literal.begin.asciidoc
      push:
        - meta_scope: meta.block.literal.content.asciidoc
        - meta_content_scope: string.literal.block.delimited.asciidoc
        - match: ^\1\s*$\n?
          scope: constant.delimiter.block.literal.end.asciidoc
          pop: true
        # - match: ^.*$\n?
        #   scope: meta.block.literal.content.asciidoc
        # - include: inline_callout
  
  #############
  # OPEN BLOCKS
  #############
  # Examples:
  #   --
  #   Lorem ipsum
  #   --

  block_open:
    - match: ^\-\-\s*$\n?
      scope: constant.delimiter.block.open.begin.asciidoc
      push:
        - meta_scope: meta.block.open.asciidoc
        - meta_content_scope: meta.block.open.content.asciidoc
        - match: ^\-\-\s*$\n?
          scope: constant.delimiter.block.open.end.asciidoc
          pop: true
        # @NOTE ORIGIN: Might need to check on these includes:
        - include: lists
        - include: block_comment
        # - include: block_listing
        - include: block_pass
        - include: lines
        - include: inline
        - include: characters

  
  
  #############
  # PASS BLOCKS
  #############

  block_pass:
    - match: ^(\+{4,})\s*$\n?
      scope: constant.delimiter.block.passthrough.begin.asciidoc
      push:
        - meta_scope: meta.embedded.block.passthrough.asciidoc
        - meta_content_scope: text.xml.block.passthrough.content.asciidoc
        - match: ^\1\s*$\n?
          scope: constant.delimiter.block.passthrough.end.asciidoc
          pop: true
      # - include: text.xml

  
  ##############
  # QUOTE BLOCKS
  ##############
  # Examples:
  #   ____
  #   Lorem ipsum
  #   ____

  block_quote:
    - match: ^(_{4,})\s*$\n?
      scope: constant.delimiter.block.quote.begin.asciidoc
      push:
        - meta_scope: meta.block.quote.content.asciidoc
        - meta_content_scope: markup.quote.block.asciidoc
        - match: ^\1\s*$\n?
          scope: constant.delimiter.block.quote.end.asciidoc
          pop: true
        - include: lines
        - include: inline
        - include: characters



  #################
  # SIDEBAR BLOCKS
  #################
  # Examples:
  #   ****
  #   Lorem ipsum
  #   ****

  block_sidebar:
    - match: ^(\*{4,})\s*$\n?
      scope: constant.delimiter.block.sidebar.begin.asciidoc
      push:
        - meta_scope: meta.block.sidebar.content.asciidoc
        - meta_content_scope: string.quoted.block.sidebar.asciidoc
        - match: ^\1\s*$\n?
          scope: constant.delimiter.block.sidebar.end.asciidoc
          pop: true
        - include: lists
        - include: block_comment
        - include: block_listing
        - include: lines
        - include: inline
        - include: characters


# -------------------------------------
# @NOTE: Was commented out in original!
# -------------------------------------
#  #block_paragraph:
#  #  comment: |
#  #    TODO
#  #  name: meta.paragraph.asciidoc
#  #  contentName: constant.character
#  #  begin: ^(?=\S)(?![\/|=\-_\.*`]{2,}(?=\s*$))(?!\.\S+)
#  #  end: ^(?:\s*$|(?=[ ]{,3}>.))|(?=[ \t]*\n)(?<=^===|^====|=====|^---|^----|-----)[\t]*\n

  #################
  # INLINE CALLOUTS
  #################
  # Callout label
  #
  # Examples:
  #   <1>
  #   <42>

  # >>>>>>>>>>>>>>>>>>>>>>>>>>>
  # inline_callout:
  #   comment: |
  #     Callout label
  #
  #     Examples:
  #       <1>
  #       <42>
  #   name: constant.other.callout.asciidoc
  #   match: (?<!\\)(<)\d+(>)
  #   captures:
  #     '1': {name: punctuation.definition.callout.begin.asciidoc}
  #     '2': {name: punctuation.definition.callout.end.asciidoc}
  # <<<<<<<<<<<<<<<<<<<<<<<<<<<


#-----------------------------------------------------------------------------#
#                             C H A R A C T E R S                             #
#-----------------------------------------------------------------------------#

  characters:
  #   - include: attribute_reference
  #   - include: entity_number
  #   - include: entity_name
  #   - include: escape
  #   - include: replacement
  #   - include: macro_pass
    - include: macro
  #   - include: xref
  #   - include: biblio_anchor
  #   - include: indexterm_triple
  #   - include: indexterm_double

  #####################
  # ATTRIBUTE REFERENCE
  #####################
  # Examples:
  #   {my-attribute}

  # >>>>>>>>>>>>>>>>>>>>>>>>>>>
  # attribute_reference:
  #   comment: |
  #     Examples:
  #       {my-attribute}
  #   name: variable.other
  #   match: ({)([A-Za-z0-9_][A-Za-z0-9_-]*)(})
  #   captures:
  #     '1': {name: constant.character.attributes.reference.begin.asciidoc}
  #     '2': {name: support.variable.attribute.asciidoc}
  #     '3': {name: constant.character.attributes.reference.end.asciidoc}
  # <<<<<<<<<<<<<<<<<<<<<<<<<<<

  ################
  # BIBLIO ANCHORS
  ################
  # Bibliography anchor
  # Examples:
  #   [[[Lorem ipsum]]]

  # >>>>>>>>>>>>>>>>>>>>>>>>>>>
  # biblio_anchor:
  #   comment: |
  #     Bibliography anchor
  #
  #     Examples:
  #       [[[Lorem ipsum]]]
  #   name: storage.type.reference.biblioanchor.asciidoc
  #   match: (?<!\[)(\[\[\[).*?(\]\]\])(?!\])
  #   captures:
  #     '1': {name: punctuation.definition.biblioanchor.begin.asciidoc}
  #     '2': {name: punctuation.definition.biblioanchor.end.asciidoc}
  # <<<<<<<<<<<<<<<<<<<<<<<<<<<

  #################
  # NUMBER ENTITIES
  #################
  # Numeric character reference
  # Examples:
  #   &#x278a;
  #   &#182;

  # >>>>>>>>>>>>>>>>>>>>>>>>>>>
  # entity_number:
  #   comment: |
  #     Numeric character reference
  #
  #     Examples:
  #       &#x278a;
  #       &#182;
  #   name: constant.character.entity.asciidoc
  #   match: (?<!\\)&#(x?[0-9a-fA-f]{2,4});
  # <<<<<<<<<<<<<<<<<<<<<<<<<<<

  #########
  # ESCAPES
  #########
  # List of special characters that may be escaped.

  # @NOTE (IN ORIGINAL): I do not really know if this is a good list, adopted
  #                      wholesale from original bundle.

  # >>>>>>>>>>>>>>>>>>>>>>>>>>>
  # escape:
  #   comment: |
  #     List of special characters that may be escaped.
  #
  #     Note: I do not really know if this is a good list, adopted wholesale from
  #     original bundle.
  #   name: constant.character.escape.asciidoc
  #   match: \\(?=[-`*_#+.!(){}\[\]\\>:])
  # <<<<<<<<<<<<<<<<<<<<<<<<<<<

  ###################
  # DOUBLE INDEXTERMS
  ###################
  # Double parenthesis indexterm.
  # Examples:
  #   ((Arthur))

  # >>>>>>>>>>>>>>>>>>>>>>>>>>>
  # indexterm_double:
  #   comment: |
  #     Double parenthesis indexterm.
  #
  #     Examples:
  #       ((Arthur))
  #   name: variable.other.indexterm.double.asciidoc
  #   match: (?<!\()(\({2})([^\(\s].*?)(\){2})(?!\))
  #   captures:
  #     '1': {name: constant.character.indexterm.double.begin.asciidoc}
  #     '3': {name: constant.character.indexterm.double.end.asciidoc}
  # <<<<<<<<<<<<<<<<<<<<<<<<<<<

  ###################
  # TRIPLE INDEXTERMS
  ###################
  # Triple parenthesis indexterm.
  # Examples:
  #   (((Sword, Broadsword, Excalibur)))

  # >>>>>>>>>>>>>>>>>>>>>>>>>>>
  # indexterm_triple:
  #   comment: |
  #     Triple parenthesis indexterm.
  #
  #     Examples:
  #       (((Sword, Broadsword, Excalibur)))
  #   name: variable.other.indexterm.triple.asciidoc
  #   match: (?<!\()(\({3})([^\(].*?)(\){3})(?!\))
  #   captures:
  #     '1': {name: constant.character.indexterm.triple.begin.asciidoc}
  #     '3': {name: constant.character.indexterm.triple.end.asciidoc}
  # <<<<<<<<<<<<<<<<<<<<<<<<<<<

  ########
  # MACROS
  ########

  # @NOTE (ORIGINAL): There are other macro notations, but I match only those
  #                   that end in square brackets.

  # @NOTE: We should really have a separate definition for links, which allows
  #        attributes and provides link-specific semantics for `title=""` and
  #        the `^` for `target_blank`, etc.

  macro:
    - include: dummy_table_opts # e.g. [cols="3*^"]
    - match: |
        (?x)
        (?:
          ((?:https?|mailto|ftp|file)  # specify separately so we can mark them as links that TextMate opens
          ?:{1}  # inline only
          \S*)   # (others such as image are partial URLs and/or TextMate cannot handle them)
        |
          (([a-zA-Z0-9][a-zA-Z0-9_]*)
          (:{1,2})
          (\S*))
        )
        (?:(\[)([^\]]*)(\]))
      captures:
        1: markup.underline.link.macro.asciidoc
        3: keyword.control.name.macro.asciidoc
        4: constant.character.separator.macro.asciidoc
        5: markup.underline.target.macro.asciidoc
        6: constant.character.attributes.macro.begin.asciidoc
        7: variable.parameter.attributes.macro.asciidoc
        8: constant.character.attributes.macro.end.asciidoc


  # >>>>>>>>>>>>>>>>>>>>>>>>>>>
  # macro:
  #   comment: |
  #     Note: There are other macro notations, but I match only those that end in
  #     square brackets.
  #   name: meta.macro.asciidoc
  #   match: |-
  #     (?x)
  #     (?:
  #       ((?:https?|mailto|ftp|file)  # specify separately so we can mark them as links that TextMate opens
  #       ?:{1}  # inline only
  #       \S*)   # (others such as image are partial URLs and/or TextMate cannot handle them)
  #     |
  #       (([a-zA-Z0-9][a-zA-Z0-9_]*)
  #       (:{1,2})
  #       (\S*))
  #     )
  #     (?:(\[)([^\]]*)(\]))
  #   captures:
  #     '1': {name: markup.underline.link.macro.asciidoc}
  #     '3': {name: keyword.control.name.macro.asciidoc}
  #     '4': {name: constant.character.separator.macro.asciidoc}
  #     '5': {name: markup.underline.target.macro.asciidoc}
  #     '6': {name: constant.character.attributes.macro.begin.asciidoc}
  #     '7': {name: variable.parameter.attributes.macro.asciidoc}
  #     '8': {name: constant.character.attributes.macro.end.asciidoc}
  # <<<<<<<<<<<<<<<<<<<<<<<<<<<

  ############
  # PASS MACRO
  ############
  # Passthrough macro
  # Examples:
  #   pass:[Lorem ipsum]
  #   pass::[Lorem ipsum]

  # >>>>>>>>>>>>>>>>>>>>>>>>>>>
  # macro_pass:
  #   comment: |
  #     Passthrough macro
  #
  #     Examples:
  #       pass:[Lorem ipsum]
  #       pass::[Lorem ipsum]
  #   name: meta.macro.pass.asciidoc
  #   contentName: variable.parameter.attributes.macro.pass.asciidoc
  #   begin: |-
  #     (?x)
  #     (pass)
  #     (:{1,2})
  #     (\S*)
  #     (\[)(?=[^\]]*\])
  #   captures:
  #     '1': {name: keyword.control.name.macro.pass.asciidoc}
  #     '2': {name: constant.character.separator.macro.asciidoc}
  #     '3': {name: markup.underline.target.macro.asciidoc}
  #     '4': {name: constant.character.attributes.macro.begin.asciidoc}
  #   end: '\]'
  #   endCaptures:
  #     '0': {name: constant.character.attributes.macro.end.asciidoc}
  #   - include: text.xml
  # <<<<<<<<<<<<<<<<<<<<<<<<<<<

  ##############
  # REPLACEMENTS
  ##############
  # >>>>>>>>>>>>>>>>>>>>>>>>>>>
  #  replacement:
  #    name: constant.character.replacement.asciidoc
  #    match: |-
  #      (?x)
  #      (?<!\\)  # must not be escaped
  #      (
  #        \(C\)
  #        | \(TM\)
  #        | \(R\)
  #        | ((?<!\-)\-\-(?!\-))    # exactly two, and even this may not rule out all that I want to
  #        | ((?<!\.)\.\.\.(?!\.))  # exactly three
  #        | \->
  #        | <\-
  #        | =>
  #        | <=
  #      )
  # <<<<<<<<<<<<<<<<<<<<<<<<<<<

  ################
  # NAMED ENTITIES
  ################
  # Character entity reference
  # Examples:
  #   &nbsp;
  #   &sup2;

  # >>>>>>>>>>>>>>>>>>>>>>>>>>>
  # entity_name:
  #   comment: |
  #     Character entity reference
  #
  #     Examples:
  #       &nbsp;
  #       &sup2;
  #   name: constant.character.entity.xml.asciidoc
  #   match: (?<!\\)&([a-zA-Z][a-zA-Z0-9]*);
  # <<<<<<<<<<<<<<<<<<<<<<<<<<<

  #######
  # XREFS
  #######
  # Internal cross-reference
  # Examples:
  #   <<lorem>>
  #   <<lorem, see here>>

  # >>>>>>>>>>>>>>>>>>>>>>>>>>>
  # xref:
  #   comment: |
  #     Internal cross-reference
  #
  #     Examples:
  #       <<lorem>>
  #       <<lorem, see here>>
  #   name: meta.xref.asciidoc
  #   match: (?<!<)(<<)([^,]*?)((,\s*)(.*?))?(>>)(?!<)
  #   captures:
  #     '1': {name: constant.character.xref.begin.asciidoc}
  #     '2': {name: markup.underline.term.xref.asciidoc}
  #     '5': {name: variable.parameter.xref.asciidoc}
  #     '6': {name: constant.character.xref.end.asciidoc}
  # <<<<<<<<<<<<<<<<<<<<<<<<<<<

#*******************************************************************************
#                                                                              *
#                        I N L I N E    E L E M E N T S                        *
#                                                                              *
#*******************************************************************************

  inline:
    - include: passthrough
    - include: strong_double
    - include: emphasis_double
    - include: monospaced_double
    - include: mark_double
    - include: strong
    - include: emphasis
    - include: monospaced
    # - include: mark           # problematic!
    - include: superscript    # problematic!
    - include: subscript


  # >>>>>>>>>>>>>>>>>>>>>>>>>>>
  # inline:
  #   - include: passthrough
  #   - include: strong_double
  #   - include: emphasis_double
  #   - include: monospaced_double
  #   - include: mark_double
  #   - include: strong
  #   - include: emphasis
  #   - include: monospaced
  #   - include: mark
  #   - include: superscript
  #   - include: subscript
  # <<<<<<<<<<<<<<<<<<<<<<<<<<<

  ######################
  # STRONG UNCONSTRAINED
  ######################
  # Was: "STRONG DOUBLE"
  # Strong (bold) text (unconstrained variant).
  # Examples:
  #   Lo**re**m **ipsum dolor**.
  #   Lo[red]**re**m

  strong_double:
    - match: |
        (?x)
        (\[[^\]]*?\])?  # might start with an attribute list
        (?<!\\)         # must not be preceded by escape
        (\*\*)
      captures:
        1: support.variable.attributelist.asciidoc
        2: punctuation.definition.bold.double.begin.asciidoc
      push: inside_strong_double

  inside_strong_double:
    - meta_content_scope: markup.bold.double.asciidoc
    - meta_scope: meta.boldinner.double.asciidoc
    - include: error_on_empty_line
    - include: line_comment
    - include: emphasis_double
    - include: emphasis
    - include: monospaced_double
    - include: monospaced
    - match: \*\*
      scope: punctuation.definition.bold.double.end.asciidoc
      pop: true
      #   - include: emphasis_double
      #   - include: monospaced_double
      #   - include: mark_double
      #   - include: emphasis
      #   - include: monospaced
      #   - include: mark
      #   - include: superscript
      #   - include: subscript
      #   - include: characters



  #####################
  # STRONG CONSTRAINED
  #####################
  # Was: "STRONG"
  # Strong (bold) text (unconstrained variant).
  # Examples:
  #   Lo**re**m **ipsum dolor**.
  #   Lo[red]**re**m
  strong:
    - match: |
        (?x)
        (\[[^\]]*?\])?      # might start with an attributes list
        (?<=^|\W)(?<!\\|})  # must be preceded by nonword character, and not by escape or } (attribute)
        (\*)(?=\S)          # delimiter star that must be followed by a nonspace character
      captures:
        1: support.variable.attributelist.asciidoc
        2: punctuation.definition.bold.single.begin.asciidoc
      push: inside_strong

  inside_strong:
    - meta_content_scope: markup.bold.single.asciidoc
    - meta_scope: meta.boldinner.single.asciidoc
    - include: error_on_empty_line
    - include: line_comment
    - include: emphasis_double
    - include: emphasis
    - include: monospaced_double
    - include: monospaced
    - match: |
        (?x)
        (?<=\S)(\*)       # delimiter star that must be preceded by a nonspace character
        (?!\w)            # ...and followed by a nonword character
      scope: punctuation.definition.bold.single.end.asciidoc
      pop: true
      #   - include: emphasis_double
      #   - include: monospaced_double
      #   - include: mark_double
      #   - include: emphasis
      #   - include: monospaced
      #   - include: mark
      #   - include: superscript
      #   - include: subscript
      #   - include: characters



  ########################
  # EMPHASIS UNCONSTRAINED
  ########################
  # Was: "EMPHASIS DOUBLE"
  # Emphasized (italic) text (unconstrained variant).
  # Examples:
  #   Lo__re__m __ipsum dolor__.
  #   Lo[red]__re__m

  emphasis_double:
    - match: |
        (?x)
        (\[[^\]]*?\])?  # might start with attribute list
        (?<!\\)         # must not be preceded by escape
        (__)
      captures:
        1: support.variable.attributelist.asciidoc
        2: punctuation.definition.italic.double.begin.asciidoc
      push: inside_emphasis_double

  inside_emphasis_double:
    - meta_content_scope: markup.italic.double.asciidoc
    - meta_scope: meta.italicinner.double.asciidoc
    - include: error_on_empty_line
    - include: line_comment
    - include: strong_double
    - include: strong
    - include: monospaced_double
    - include: monospaced
    - match: '__'
      scope: punctuation.definition.italic.double.end.asciidoc
      pop: true
    #   - include: strong_double
    #   - include: monospaced_double
    #   - include: mark_double
    #   - include: strong
    #   - include: monospaced
    #   - include: mark
    #   - include: superscript
    #   - include: subscript
    #   - include: characters



  ######################
  # EMPHASIS CONSTRAINED
  ######################
  # Was: "EMPHASIS"
  # Emphasized (italic) text (constrained variant).
  #
  # Examples:
  #   _Lorem ipsum_ dolor
  #   [red]_Lorem ipsum_ dolor

  emphasis:
    - match: |
        (?x)
        (\[[^\]]*?\])?      # might be preceded by an attributes list
        (?<=^|\W)(?<!\\|})  # must be preceded by nonword character, and not by escape or } (attribute)
        (_)(?=\S)           # delimiter underscore that must be followed by a nonspace character
      captures:
        1: support.variable.attributelist.asciidoc
        2: punctuation.definition.italic.single.begin.asciidoc
      push: inside_emphasis

  inside_emphasis:
    - meta_content_scope: markup.italic.single.asciidoc
    - meta_scope: meta.italicinner.single.asciidoc
    - include: error_on_empty_line
    - include: line_comment
    - include: strong_double
    - include: strong
    - include: monospaced_double
    - include: monospaced
    - match: |
        (?x)
        (?<=\S)(_)        # delimiter underscore that must be preceded by a nonspace character
        (?!\w)            # ...and followed by a nonword character
      scope: punctuation.definition.italic.single.end.asciidoc
      pop: true
    # - include: strong_double
    # - include: monospaced_double
    # - include: mark_double
    # - include: strong
    # - include: monospaced
    # - include: mark
    # - include: superscript
    # - include: subscript
    # - include: characters



  ##########################
  # MONOSPACED UNCONSTRAINED
  ##########################
  # Was: "MONOSPACED DOUBLE"
  # Monospaced text (unconstrained variant).
  #
  # Examples:
  #   Lo``re``m ``ipsum dolor``.
  #   Lo[red]``re``m

  monospaced_double:
    - match: |
        (?x)
        (\[[^\]]*?\])?  # might start with attribute list
        (?<!\\)         # must not be preceded by escape
        (``)
        (?!"|')         # Avoid false positive for closing smart typography
      captures:
        1: support.variable.attributelist.asciidoc
        2: punctuation.definition.literal.double.begin.asciidoc
      push: inside_monospaced_double

  inside_monospaced_double:
    - meta_content_scope: string.other.literal.double.asciidoc
    - meta_scope: meta.literalinner.double.asciidoc
    - include: error_on_empty_line
    - include: line_comment
    - match: '``'
      scope: punctuation.definition.literal.double.end.asciidoc
      pop: true
    # - include: strong_double
    # - include: emphasis_double
    # - include: mark_double
    # - include: strong
    # - include: emphasis
    # - include: mark
    # - include: superscript
    # - include: subscript
    # - include: characters



  ########################
  # MONOSPACED CONSTRAINED
  ########################
  # Was: "MONOSPACED"
  # Monospaced text (constrained variant).
  #
  # Examples:
  #   `Lorem ipsum` dolor
  #   [red]`Lorem ipsum` dolor

  monospaced:
    # False positive: typographic quotes followed by single backtick:
    - match: (["']`)(`(?!`))?
      captures:
        1: punctuation.definition.string.begin.asciidoc
      pop: true
    # False positive: closing typographic quotes:
    - match: (`["'])
      captures:
        1: punctuation.definition.string.end.asciidoc
      pop: true
    # Capture real monospaced formatting:
    - match: |
        (?x)
        (\[[^\]]*?\])?      # might start with attributes list
        (?<=^|\W)(?<!\\|})  # must be preceded by nonword character, and not by escape or } (attribute)
        (`)(?=\S)           # delimiter backtick that must be followed by a nonspace character
      captures:
        1: support.variable.attributelist.asciidoc
        2: punctuation.definition.literal.single.begin.asciidoc
      push: inside_monospaced

  inside_monospaced:
    - meta_content_scope: string.other.literal.single.asciidoc
    - meta_scope: meta.literalinner.single.asciidoc
    - include: error_on_empty_line
    - include: line_comment
    - match: |
        (?x)
        (?<=\S)(`)        # delimiter backtick that must be preceded by a nonspace character
        (?!\w)            # ...and followed by a nonword character
      scope: punctuation.definition.literal.single.end.asciidoc
      pop: true
  #   - include: strong_double
  #   - include: emphasis_double
  #   - include: mark_double
  #   - include: strong
  #   - include: emphasis
  #   - include: mark
  #   - include: superscript
  #   - include: subscript
  #   - include: characters





  #############
  # PASSTHROUGH
  #############
  # Inline triple-plus and double dollar passthrough.
  # Examples:
  #   Lo+++re++++m +++ipsum dolor+++.
  #   Lo$$re$$m $$ipsum dolor$$.

  # @NOTE ORIGINAL: Must be dead-first among the inlines, so as to take priority.

  passthrough:
    - match: (\+\+\+|\$\$)
      scope: constant.character.passthru.begin.asciidoc
      push:
        - meta_scope: meta.passthru.inline.asciidoc
        - meta_content_scope: variable.parameter.passthruinner.asciidoc
        - match: \1
          scope: constant.character.passthru.end.asciidoc
          pop: true



  ####################
  # MARK UNCONSTRAINED
  ####################
  # Was: "MARK DOUBLE"
  # Marked text (unconstrained variant).
  # Examples:
  #   Lo##re##m ##ipsum dolor##.
  #   Lo[red]##re##m

  mark_double:
    - match: |
        (?x)
        (\[[^\]]*?\])?  # might start with an attribute list (indeed, that is its purpose)
        (?<!\\)         # must not be preceded by escape
        (\#\#)
      captures:
        1: support.variable.attributelist.asciidoc
        2: punctuation.definition.string.unquoted.double.begin.asciidoc
      push:
        - meta_scope: string.other.unquoted.double.asciidoc
        - meta_content_scope: string.unquoted.unquotedinner.double.asciidoc
        - match: \#\#
          scope: punctuation.definition.string.unquoted.double.end.asciidoc
          pop: true
        #   - include: strong_double
        #   - include: emphasis_double
        #   - include: monospaced_double
        #   - include: strong
        #   - include: emphasis
        #   - include: monospaced
        #   - include: superscript
        #   - include: subscript
        #   - include: characters


  ##################
  # MARK CONSTRAINED
  ##################
  # Was: "MARK"
  # Marked text (constrained variant).
  # Examples:
  #   #Lorem ipsum# dolor
  #   [red]#Lorem ipsum# dolor

  # @PROBLEM: Braks everything! seems like optional "start with attribute"
  #           causes anything to matche anything else!
#  mark:
#    - match: |
#        (?x)
#        (\[[^\]]*?\])?      # might start with attribute list (darned well better or why are we here)
#        (?<=^|\W)(?<!\\|})  # must be preceded by nonword character, and not by escape or } (attribute)
#        (\#)(?=\S)          # delimiter hash that must be followed by a nonspace character
#      captures:
#        1: support.variable.attributelist.asciidoc
#        2: punctuation.definition.string.unquoted.single.begin.asciidoc
#      push:
#        - meta_scope: string.other.unquoted.single.asciidoc
#        - meta_content_scope: string.unquoted.unquotedinner.single.asciidoc
#        - match: |
#            (?x)
#            (?<=\S)(\#)       # delimiter hash that must be preceded by a nonspace character
#            (?!\w)            # ...and followed by a nonword character
#          scope: punctuation.definition.string.unquoted.single.end.asciidoc
#          pop: true
#        # - include: strong_double
#        # - include: emphasis_double
#        # - include: monospaced_double
#        # - include: strong
#        # - include: emphasis
#        # - include: monospaced
#        # - include: superscript
#        # - include: subscript
#        # - include: characters


  ###########
  # SUBSCRIPT
  ###########
  # Subscript text.
  # Examples:
  #   E=mc^2^
  #   E=mc[red]^2^

  subscript:
    - match: |
        (?x)
        (\[[^\]]*?\])?  # might start with attribute list
        (?<!\\)         # must not be preceded by escape
        (~)
      captures:
        1: support.variable.attributelist.asciidoc
        2: punctuation.definition.string.subscript.begin.asciidoc
      push:
        - meta_scope: meta.subscriptinner.asciidoc
        - meta_content_scope: string.other.subscript.asciidoc
        - match: \~
          scope: punctuation.definition.string.subscript.end.asciidoc
          pop: true
      #   - include: strong_double
      #   - include: emphasis_double
      #   - include: monospaced_double
      #   - include: mark_double
      #   - include: strong
      #   - include: emphasis
      #   - include: monospaced
      #   - include: mark
      #   - include: superscript
      #   - include: characters



  #############
  # SUPERSCRIPT
  #############
  # Superscript text.
  # Examples:
  #   H~2~O
  #   H[red]~2~O

  superscript:
    - match: |
        (?x)
        (\[[^\]]*?\])?  # might start with attribute list
        (?<!\\)         # no preceding escape
        (\^)
      captures:
        1: support.variable.attributelist.asciidoc
        2: punctuation.definition.string.superscript.begin.asciidoc
      push:
        - meta_scope: meta.superscriptinner.asciidoc
        - meta_content_scope: string.other.superscript.asciidoc
        - match: \^
          scope: punctuation.definition.string.superscript.end.asciidoc
          pop: true
      #   - include: strong_double
      #   - include: emphasis_double
      #   - include: monospaced_double
      #   - include: mark_double
      #   - include: strong
      #   - include: emphasis
      #   - include: monospaced
      #   - include: mark
      #   - include: subscript
      #   - include: characters



#*******************************************************************************
#                                                                              *
#                   S I N G L E - L I N E    E L E M E N T S                   *
#                                                                              *
#*******************************************************************************

  lines:
    - include: line_comment
    - include: list_continuation
    - include: inline_break
    - include: block_page_break
    - include: block_thematic_break
    - include: block_title
    - include: block_id
  #   - include: block_req                              # <- ADDED by @bsmith-n4
  #   - include: section_template
  #   - include: attribute_list_line
    - include: attribute_entry

  ######################
  # SINGLE-LINE COMMENTS
  ######################
  # Inline comment. (?)
  # Examples:
  #   // This is just a comment!
  line_comment:
    - match: ^(//)([^/\n].*|)$\n?
      scope: comment.line.double-slash.asciidoc
      captures:
        1: punctuation.definition.comment.line.asciidoc
        2: meta.line.comment.content.asciidoc


  #################
  # ATTRIBUTE ENTRY
  #################
  # An attribute entry.
  # Examples:
  #   :my-attribute: value
  #   :sectnums!:
  #   :!sectnums:

  attribute_entry:
    - match: |
        (?x)
        ^(:)                          # 1: opening delimiter
        (!)?                          # 2: bang symbol (unset attribute)
        ([A-Za-z0-9_][A-Za-z0-9_-]*)  # 3: attribute name
        (!)?                          # 4: bang symbol (unset attribute)
        (:)                           # 5: closing delimiter
        (?:\s+|(?=$))                 # ? consume WS?
      captures:
        1: punctuation.definition.attributeentry.attrname.begin.asciidoc
        2: punctuation.definition.attributeentry.unset.asciidoc
        3: support.variable.attribute.asciidoc
        4: punctuation.definition.attributeentry.unset.asciidoc
        5: punctuation.definition.attributeentry.attrname.end.asciidoc
      push:
        - meta_scope: meta.attributeentry.asciidoc
        - meta_content_scope: meta.attributeentry.value.asciidoc
        - match: $\n?
          pop: true
        #   - include: characters


  #####################
  # ATTRIBUTE LIST LINE
  #####################
  # Attribute list as paragraph: single brackets. No need for special
  # treatment of escape; follows literal block, section template as being a
  # more general regex.

  # >>>>>>>>>>>>>>>>>>>>>>>>>>>
  # attribute_list_line:
  #   comment: >
  #     Attribute list as paragraph: single brackets. No need for special
  #     treatment of escape; follows literal block, section template as being a
  #     more general regex.
  #   name: support.variable.attributelist.asciidoc
  #   match: ^(\[)[^\[\]]*(\])\s*$\n?
  #   captures:
  #     '1': {name: punctuation.definition.attributelistline.begin.asciidoc}
  #     '2': {name: punctuation.definition.attributelistline.end.asciidoc}
  # <<<<<<<<<<<<<<<<<<<<<<<<<<<

  #############
  # BLOCK TITLE
  #############
  # Title of a block. Excludes custom block titles for better
  # scoping / preventing overlap.
  # Examples:
  #   .My title
  #   Lorem ipsum dolor.

  block_title:
    - match: ^(\.)(\w.*)$\n?
      captures:
        1: punctuation.definition.blockheading.asciidoc
        2: markup.heading.block.asciidoc


  ##########
  # BLOCK ID
  ##########
  # A block id (i.e. anchor).
  # Examples:
  #   [[myid]]
  #   Lorem ipsum dolor.

  block_id:
    - match: ^(\[\[)([^\[].*)(\]\])\s*$\n?
      captures:
        0: meta.tag.blockid.asciidoc
        1: punctuation.definition.blockid.begin.asciidoc
        2: markup.underline.blockid.id.asciidoc
        3: punctuation.definition.blockid.end.asciidoc


  ###########
  # BLOCK REQ
  ###########
  # A requirement id (i.e. anchor).
  # Examples:
  #   [req,id=ROPR1234,version=1]
  #   Lorem ipsum dolor.

  # IMPORTANT: This element was ADDED by @bsmith-n4!

  # >>>>>>>>>>>>>>>>>>>>>>>>>>>                         # <- ADDED by @bsmith-n4
  # block_req:
  #   comment: |
  #     A requirement id (i.e. anchor).
  #     Examples:
  #       [req,id=ROPR1234,version=1]
  #       Lorem ipsum dolor.
  #   name: meta.tag.blockid.req.asciidoc
  #   match: (\[req,(\s+)?id=)(.+?)(,(\s+)?version=)([0-9])(\])
  #   captures:
  #     '1': {name: markup.underline.block.id.asciidoc}
  #     '3': {name: variable.parameter.reqid.id.asciidoc}
  #     '4': {name: markup.underline.block.version.asciidoc}
  #     '6': {name: variable.parameter.reqversion.id.asciidoc}
  #     '7': {name: markup.underline.block.id.asciidoc}
  # <<<<<<<<<<<<<<<<<<<<<<<<<<<


  ##############
  # INLINE BREAK
  ##############
  # Line hard break with a plus sign (+).
  # Examples:
  #   Rubies are red, +
  #   Topazes are blue.

  inline_break:
    - match: (?<=\s)\+$\n?
      scope: constant.linebreak.asciidoc


  ###################
  # LIST CONTINUATION
  ###################
  # See: ยง20.2.1. List continuation
  # https://asciidoctor.org/docs/user-manual/#list-continuation

  # Examples:
  #  * First list element paragraph.
  #  +
  #  Second element paragraph (no bullet).

  list_continuation:
    - match: ^\+\s*$\n?
      scope: constant.listcontinuation.asciidoc


  ##################
  # BLOCK PAGE BREAK
  ##################
  # A page break.
  # Examples:
  #   <<<
  #   <<<<<

  block_page_break:
    - match: ^<{3,}$\n?
      scope: meta.separator.pagebreak.asciidoc



  ######################
  # BLOCK THEMATIC BREAK
  ######################
  # A thematic break (aka horizontal rule).
  # Examples:
  #   '''
  #   ''''''

  block_thematic_break:
    - match: ^'{3,}$\n?
      scope: meta.separator.ruler.asciidoc



  ##################
  # SECTION TEMPLATE
  ##################
  # Fixed list of known template names
  # See: ยง16.9. Section Styles
  # https://asciidoctor.org/docs/user-manual/#section-styles

  # IMPORTANT: This element differs in @bsmith-n4 and original!
  #
  # section_template:
  #   comment: fixed list of known template names
  #   name: variable.parameter.sectiontemplate.asciidoc
  #   match: |-



  # >>>>>>>>>>>>>>>>>>>>>>>>>>>
  # section_template:
  #   comment: fixed list of known template names
  #   name: variable.parameter.sectiontemplate.asciidoc
  #   match: |                       # <- CHANGED by @bsmith-n4 (was: match: |-)
  #     (?x)^
  #     (\[)  # in square brackets
  #     (template\s*=\s*)?(")?  # might start with template-equals and might have template name in quotes
  #     (
  #     sect\d|abstract|preface|colophon|dedication|glossary|bibliography|synopsis|appendix|index # fixed list of known templates
  #     )
  #     (".*(\])|(\]))  # either close the quote (and perhaps go on) and close the bracket, or close the bracket immediately
  #     \s*$\n?
  #   captures:
  #     '1': {name: punctuation.definition.sectiontemplate.begin.asciidoc}
  #     '4': {name: meta.tag.sectiontemplate.asciidoc}
  #     '6': {name: punctuation.definition.sectiontemplate.end.asciidoc}
  #     '7': {name: punctuation.definition.sectiontemplate.end.asciidoc}
  # <<<<<<<<<<<<<<<<<<<<<<<<<<<

#*******************************************************************************
#                                                                              *
#                                  L I S T S                                   *
#                                                                              *
#*******************************************************************************

  lists:
    - include: ulist_item_marker
  # lists:
  #   comment: >
  #     My strategy for lists (and similar) is not to try to treat entire
  #     paragraphs as lists, but only call out the opening.
  #   - include: block_admonition_label
  #   - include: ulist_item_marker
  #   - include: olist_item_marker
  #   - include: dlist_item_label
  #   - include: colist_item_marker

  ########################
  # ADMONITION BLOCK LABEL
  ########################
  # Label of an admonition block.
  # Examples:
  #   NOTE: This is a admonition block.
  #   WARNING:  Be aware of them!

  # >>>>>>>>>>>>>>>>>>>>>>>>>>>
  # block_admonition_label:
  #   comment: |
  #     Label of an admonition block.
  #
  #     Examples:
  #       NOTE: This is a admonition block.
  #       WARNING:  Be aware of them!
  #   name: support.constant.admonitionword.asciidoc
  #   match: ^(NOTE|TIP|IMPORTANT|WARNING|CAUTION):(?=\s+)
  # <<<<<<<<<<<<<<<<<<<<<<<<<<<

  ###################
  # ULIST ITEM MARKER
  ###################
  # Marker of an unordered (bullet) list item.
  # Examples:
  #   - level 1
  #   * level 1
  #   ** level 2
  #   *** level 3
  #   **** level 4
  #   ***** level 5

  ulist_item_marker:
    - match: ^\s*(\-|\*{1,5})\s+(?=\S)
      captures:
        1: punctuation.definition.list_item.asciidoc


  ####################
  # COLIST ITEM MARKER
  ####################
  # Marker of a callout list item.
  # Examples:
  #   <1> a callout
  #   <42> another callout

  # >>>>>>>>>>>>>>>>>>>>>>>>>>>
  # colist_item_marker:
  #   comment: |
  #     Marker of a callout list item.
  #
  #     Examples:
  #       <1> a callout
  #       <42> another callout
  #   name: markup.list.numbered.callout.asciidoc
  #   match: ^(\s*((<)\d+?(>)))\s+(?=\S)
  #   captures:
  #     '1': {name: string.unquoted.list.callout.asciidoc}
  #     '2': {name: constant.numeric.callout.asciidoc}
  #     '3': {name: punctuation.definition.calloutlistnumber.begin.asciidoc}
  #     '4': {name: punctuation.definition.calloutlistnumber.end.asciidoc}
  # <<<<<<<<<<<<<<<<<<<<<<<<<<<

  ##################
  # DLIST ITEM LABEL
  ##################
  # Label of a definition (labeled) list item.
  # Examples:
  #   Label level 1:: lorem ipsum
  #   Label level 2::: dolor sit amet
  #   Label level 3:::: consectetur
  #   Label level 1::
  #     lorem ipsum
  #   Another label :: lorem ipsum
  #   Last::label:: dolor sit amet

  # @NOTE (ORIGINAL):
  #     This rule is not strictly correct, because Asciidoctor allows
  #     double colon followed by a space inside a label, i.e. it matches the
  #     *last* double colon, not the first. I don't know how to do that
  #     *effectively.

  # >>>>>>>>>>>>>>>>>>>>>>>>>>>
  # dlist_item_label:
  #   comment: |
  #     Label of a definition (labeled) list item.
  #
  #     Examples:
  #       Label level 1:: lorem ipsum
  #       Label level 2::: dolor sit amet
  #       Label level 3:::: consectetur
  #       Label level 1::
  #         lorem ipsum
  #       Another label :: lorem ipsum
  #       Last::label:: dolor sit amet
  #
  #     Note: This rule is not strictly correct, because Asciidoctor allows
  #     double colon followed by a space inside a label, i.e. it matches the
  #     *last* double colon, not the first. I don't know how to do that
  #     *effectively.
  #   name: markup.list.labeled.asciidoc
  #   contentName: meta.list.label.asciidoc
  #   begin: ^\s*(?=.*:{2,4}(?:\s|$))
  #   end: (:{2,4})(?:\s|$\n?)
  #   endCaptures:
  #     '1': {name: constant.labeledlist.separator.asciidoc}
  #   - include: inline
  #   - include: characters
  # <<<<<<<<<<<<<<<<<<<<<<<<<<<

  ###################
  # OLIST ITEM MARKER
  ###################
  # Marker of an ordered (numbered) list item.
  # Examples:
  #   . level 1
  #   .. level 2
  #   ... level 3
  #   .... level 4
  #   ..... level 5

  # >>>>>>>>>>>>>>>>>>>>>>>>>>>
  # olist_item_marker:
  #   comment: |
  #     Marker of an ordered (numbered) list item.
  #
  #     Examples:
  #       . level 1
  #       .. level 2
  #       ... level 3
  #       .... level 4
  #       ..... level 5
  #
  #     Note: The space distinguishes it from a block title.
  #   name: markup.list.numbered.dotted.asciidoc
  #   match: ^(\s*(\.{1,5}))\s+(?=\S)
  #   captures:
  #     '1': {name: string.unquoted.list.dotted.asciidoc}
  #     '2': {name: constant.numeric.list.dot.asciidoc}
  # <<<<<<<<<<<<<<<<<<<<<<<<<<<

# ==============================================================================
#                          S E C T I O N    T I T L E S
# ==============================================================================

# IMPORTANT: All Titles RegExs were tweaked by @bsmith-n4! Basically, every
#            RegEx was tweaked to allow inline code inside the title:
#
#               match: ^(=) (\w.*)$\n?     <-- original
#               match: ^(=) (`?\w.*)$\n?   <-- @bsmith-n4


#     Examples:
#
#       = Document Title (Level 0)
#
#       == Level 1 Section
#
#       === Level 2 Section

  section_titles:
    - include: title_level_5
    - include: title_level_4
    - include: title_level_3
    - include: title_level_2
    - include: title_level_1
    - include: title_level_0

  title_level_0:
    - match: ^(=) (`?\w.*)$\n?
      scope: markup.heading.level.0.asciidoc
      captures:
        1: punctuation.definition.heading.asciidoc
        2: entity.name.section.asciidoc


  title_level_1:
    - match: ^(==) (`?\w.*)$\n?
      scope: markup.heading.level.1.asciidoc
      captures:
        1: punctuation.definition.heading.asciidoc
        2: entity.name.section.asciidoc


  title_level_2:
    - match: ^(===) (`?\w.*)$\n?
      scope: markup.heading.level.2.asciidoc
      captures:
        1: punctuation.definition.heading.asciidoc
        2: entity.name.section.asciidoc


  title_level_3:
    - match: ^(====) (`?\w.*)$\n?
      scope: markup.heading.level.3.asciidoc
      captures:
        1: punctuation.definition.heading.asciidoc
        2: entity.name.section.asciidoc


  title_level_4:
    - match: ^(=====) (`?\w.*)$\n?
      scope: markup.heading.level.4.asciidoc
      captures:
        1: punctuation.definition.heading.asciidoc
        2: entity.name.section.asciidoc


  title_level_5:
    - match: ^(======) (`?\w.*)$\n
      scope: markup.heading.level.5.asciidoc
      captures:
        1: punctuation.definition.heading.asciidoc
        2: entity.name.section.asciidoc


#*******************************************************************************
#                                                                              *
#                              R E U S A B L E S                               *
#                                                                              *
#*******************************************************************************
# Resuable contexts...

  #####################
  # ERROR ON EMPTY LINE
  #####################
  # Some element (e.g. quotes) can span multiple lines as long as no empty line
  # is placed between the opening and closing delimiter...
  error_on_empty_line:
    - match: ^\n$
      scope: invalid.illegal.asciidoc
      pop: true

  ##############
  # ANY COMMENTS     ( UNUSED! )
  ##############
  # Include any type of comments.
  any_comments:
    - include: line_comment
    - include: block_comment

#*******************************************************************************
#                                                                              *
#                            M I S C E L A N N E A                             *
#                                                                              *
#*******************************************************************************
# Various definitions added by me, some of which still unused except for tests!

  ####################
  # TYPOGRAPHIC QUOTES
  ####################
  # Added by me to prevent false-positives with monospace...
  # STATUS: UNUSED DRAFT!

  curly_quotes: # NOT USED!
    - match: ("|')(`)
      scope: punctuation.definition.string.begin.asciidoc
    - match: (`)("|')
      scope: punctuation.definition.string.end.asciidoc
      # push:
      #   - match: (`)(\1)
      #     scope: punctuation.definition.string.end.asciidoc
      #     pop: true
      #   - include: monospaced_double # Single backticks are literals!


# /// EOF ///

